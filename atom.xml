<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>波波微课</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-06-15T07:17:49.913Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>波波老师</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>微服务架构~BFF和网关是如何演化出来的</title>
    <link href="http://yoursite.com/2018/06/07/2018060702/"/>
    <id>http://yoursite.com/2018/06/07/2018060702/</id>
    <published>2018-06-07T05:51:33.000Z</published>
    <updated>2018-06-15T07:17:49.913Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>BFF(Backend for Frontend)和网关Gateway是微服务架构中的两个重要概念，这两个概念相对比较新，有些开发人员甚至是架构师都不甚理解。</p><p>本文用假想的公司案例+图示的方式，解释BFF和网关是什么，它们是怎么演化出来的。希望对架构师设计和落地微服务架构有所启发。</p><a id="more"></a><h3 id="服务化架构V1"><a href="#服务化架构V1" class="headerlink" title="服务化架构V1"></a>服务化架构V1</h3><p>我们先把时间推回到大致2011年左右。假设有一家有一定业务体量的电商公司CoolShop，在这个时间点它已经完成单块应用的解构拆分，内部SOA服务化已经初步完成。这个时候它的无线应用还没有起步，前端用户体验层主要是传统的服务端Web应用，总体服务化架构V1如下图所示。</p><p><img src="/images/2018060702/soa_v1.png" alt="soa v1"></p><h3 id="服务化架构V2"><a href="#服务化架构V2" class="headerlink" title="服务化架构V2"></a>服务化架构V2</h3><p>时间转眼来到2012年初，国内的无线应用开始起风，CoolShop公司也紧跟市场趋势，研发自己的无线原生App。为了能尽快上线，公司的架构师提出如下V2架构，让App直接调用内部的服务：</p><p><img src="/images/2018060702/soa_v2.png" alt="soa v2"></p><p>这个架构有如下问题：</p><ol><li>无线App和内部微服务强耦合，任何一边的变化都可能对另外一边造成影响。</li><li>无线App需要知道内部服务的地址等细节。</li><li>无线App端需要开发大量的聚合裁剪和适配逻辑：<ul><li><strong>聚合</strong>：某一个功能需要同时调用几个后端API进行组合，比如首页需要显示分类和产品细节，就要同时调用分类API和产品API，不能一次调用完成。</li><li><strong>裁剪</strong>：后端服务返回的Payload一般比较通用，App需要根据设备类型进行裁剪，比如手机屏幕小，需要多裁掉一些不必要的内容，Pad的屏幕比较大，可以少裁掉一些内容。</li><li><strong>适配</strong>：一种常见的适配场景是格式转换，比如有些后台服务比较老，只支持老的SOAP/XML格式，不支持新的JSON格式，则无线App需要适配处理不同数据格式。</li></ul></li><li>随着设备类型的增多(iPhone/Android/iPad/WindowsPhone)，聚合裁剪和适配逻辑的开发会造成设备端的大量重复劳动。</li></ol><h3 id="服务化架构V2-1"><a href="#服务化架构V2-1" class="headerlink" title="服务化架构V2.1"></a>服务化架构V2.1</h3><p>V2架构问题太多，没有开发实施。为解决上述问题，架构师经过思考决定在外部设备和内部微服务之间引入一个新的角色~Mobile BFF。</p><p>所谓BFF其实是Backend for Frontend的简称，中文翻译是为前端而开发的后端，它主要由前端团队开发（后端微服务一般由后端团队开发）。BFF可以认为是一种适配服务，将后端的微服务进行适配（主要包括聚合裁剪和格式适配等逻辑），向无线端设备暴露友好和统一的API，方便无线设备接入访问后端服务。</p><p>新的V2.1架构如下图所以：</p><p><img src="/images/2018060702/soa_v2.1.png" alt="soa v2.1"></p><p>这个架构的优势是：</p><ol><li>无线App和内部微服务不耦合，通过引入BFF这层间接，使得两边可以独立变化：<ul><li>后端如果发生变化，通过BFF屏蔽，前端设备可以做到不受影响。</li><li>前端如果发生变化，通过BFF屏蔽，后端微服务可以暂不变化。</li><li>当无线App有新的需求时，通过BFF的屏蔽，可以减少前后端团队的沟通协调开销，很多需求由前端团队在BFF上就可以自己搞定。</li></ul></li><li>无线App只需要知道Mobile BFF的地址，并且服务接口是统一的，不需要知道内部复杂微服务的地址和细节。</li><li>聚合裁剪和适配逻辑在Mobile BFF上实现，无线App端可以大大简化瘦身。</li></ol><h3 id="服务化架构V3"><a href="#服务化架构V3" class="headerlink" title="服务化架构V3"></a>服务化架构V3</h3><p>V2.1架构比较成功，实施落地以后支持了CoolShop公司早期无线业务的成长。随着业务量进一步增长，投入无线研发的团队也不断增加，V2.1架构也逐渐暴露出如下问题：</p><ol><li>刚开始只有一个Mobile BFF，是个单块，但是无线研发团队在不断增加，分别对应多条业务线。根据康威法则，单块的无线BFF和多团队之间就出现不匹配问题，团队之间沟通协调成本高，交付效率低下。</li><li>Mobile BFF里头不仅有各个业务线的聚合/裁剪/适配和业务逻辑，还引入了很多跨横切面逻辑，比如安全认证，日志监控，限流熔断等。随着时间的推移，代码变得越来越复杂，技术债越堆越多，开发效率不断下降，缺陷数量不断增加。</li><li>Mobile BFF集群是个失败单点(Single Point of Failure)，严重代码缺陷或者流量洪峰可能引发集群宕机，所有无线应用都不可用。</li></ol><p>为了解决上述问题，架构师经过思考决定在外部设备和内部BFF之间再引入一个新的角色~API Gateway，新的架构V3如下图所示：</p><p><img src="/images/2018060702/soa_v3.png" alt="soa v3"></p><p>新的架构V3有如下调整：</p><ol><li>BFF按团队或业务线进行解耦拆分，拆分成若干个BFF微服务，每个业务线可以并行开发和交付各自负责的BFF微服务。</li><li>网关（一般由独立框架团队负责运维）专注跨横切面(Cross-Cutting Concerns)的功能，包括：<ul><li><strong>路由</strong>，将来自无线设备的请求路由到后端的某个微服务BFF集群。</li><li><strong>认证</strong>，对涉及敏感数据的API访问进行集中认证鉴权。</li><li><strong>监控</strong>，对API调用进行性能监控。</li><li><strong>限流熔断</strong>，当出现流量洪峰，或者后端BFF/微服务出现延迟或故障，网关能够主动进行限流熔断，保护后端服务，并保持前端用户体验可以接受。</li><li><strong>安全防爬</strong>，收集访问日志，通过后台分析出恶意行为，并阻断恶意请求。</li></ul></li><li>网关在无线设备和BFF之间又引入了一层间接，让两边可以独立变化，特别是当后台BFF在升级或迁移时，可以做到用户端应用不受影响。</li></ol><p>在新的V3架构中，网关承担了重要的角色，它是解耦拆分和后续升级迁移的利器。在网关的配合下，单块BFF实现了解耦拆分，各业务线团队可以独立开发和交付各自的微服务，研发效率大大提升。另外，把跨横切面逻辑从BFF剥离到网关上去以后，BFF的开发人员可以更加专注业务逻辑交付，实现了架构上的关注分离(Separation of Concerns)。</p><h3 id="服务化架构V4"><a href="#服务化架构V4" class="headerlink" title="服务化架构V4"></a>服务化架构V4</h3><p>业务在不断发展，技术架构也需要不断的调整来应对需求的变化。近年，CoolShop公司技术团队又迎来了新的业务和技术需求，主要是：</p><ol><li>开放内部的业务能力，建设CoolShop Open API平台。借助第三方社区开发者的力量，在CoolShop平台上进行创新，进一步拓宽CoolShop的应用和业务形态。</li><li>废弃传统的服务端Web应用模式，引入前后分离架构，前端采用H5单页等技术给用户提供更好的体验。</li></ol><p>为满足业务需求，架构师对服务化架构又进行了拓展升级，新的V4新架构如下图所示：</p><p><img src="/images/2018060702/soa_v4.png" alt="soa v4"></p><p>V4整体思路和V3类似，只是拓展了新的接入渠道:</p><ol><li>引入面向第三方开放API的BFF层和配套的网关，支持第三方开发者在CoolShop Open API平台上开发应用。</li><li>引入面向H5应用的BFF层和配套的网关，支持前后分离和H5单页应用模式。</li></ol><p>V4是一个比较完整的现代微服务架构，从外到内依次分为：端用户体验层-&gt;网关层-&gt;BFF层-&gt;微服务层。整个架构层次清晰，职责分明，是一种灵活的能够支持业务不断创新的演化式架构。</p><h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><ol><li>在微服务架构中，BFF(Backend for Frontend)也称聚合层或者适配层，它主要承接一个适配角色：将内部复杂的微服务，适配成对各种不同用户体验（无线/Web/H5/第三方等）友好和统一的API。聚合裁剪适配是BFF的主要职责。</li><li>在微服务架构中，网关专注解决跨横切面逻辑，包括路由、安全、监控和限流熔断等。网关一方面是拆分解耦的利器，同时让开发人员可以专注业务逻辑的实现，达成架构上的关注分离。</li><li>端用户体验层-&gt;网关层-&gt;BFF层-&gt;微服务层，是现代微服务架构的典型分层方式，这个架构能够灵活应对业务需求的变化，是一种支持创新的演化式架构。</li><li>技术和业务都在不断变化，架构师要不断调整架构应对这些的变化，BFF和网关都是架构演化的产物。</li><li>波波近期和极客时间合作，推出一门叫《微服务架构160讲》的视频课程，其中第三个模块（预计6月推出），会对Netflix新近推出的微服务网关Zuul2的架构和实践进行深度剖析，欢迎大家关注。</li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;BFF(Backend for Frontend)和网关Gateway是微服务架构中的两个重要概念，这两个概念相对比较新，有些开发人员甚至是架构师都不甚理解。&lt;/p&gt;
&lt;p&gt;本文用假想的公司案例+图示的方式，解释BFF和网关是什么，它们是怎么演化出来的。希望对架构师设计和落地微服务架构有所启发。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务架构" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="BFF" scheme="http://yoursite.com/tags/BFF/"/>
    
      <category term="网关" scheme="http://yoursite.com/tags/%E7%BD%91%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>微服务架构~为什么要配置中心</title>
    <link href="http://yoursite.com/2018/06/07/2018060701/"/>
    <id>http://yoursite.com/2018/06/07/2018060701/</id>
    <published>2018-06-07T03:23:10.000Z</published>
    <updated>2018-06-15T08:00:31.921Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>在系统架构中，和安全、日志、监控等非功能需求一样，配置管理也是一种非功能需求。配置中心是整个微服务基础架构体系中的一个组件，如下图，它的功能看上去并不起眼，无非就是简单配置的管理和存取，但它是整个微服务架构中不可或缺的一环。另外，配置中心如果真得用好了，它还能推动技术组织持续交付和DevOps文化转型。</p><a id="more"></a><p><img src="/images/2018060701/msa_tech_stack.png" alt="微服务基础架构体系"></p><p>本文介绍在分布式微服务环境下，应用配置管理背后的业务需求，配置的各种分类和一些高级应用场景。</p><h3 id="一、配置定义和形态"><a href="#一、配置定义和形态" class="headerlink" title="一、配置定义和形态"></a>一、配置定义和形态</h3><p><strong>配置其实是独立于程序的可配变量</strong>，同一份程序在不同配置下会有不同的行为，常见的配置有连接字符串，应用配置和业务配置等。</p><p>配置有多种形态，下面是一些常见的：</p><ul><li><strong>程序内部hardcode</strong>，这种做法是反模式，一般我们<strong>不建议！</strong></li><li><strong>配置文件</strong>，比如Spring应用程序的配置一般放在<code>application.properties</code>文件中。</li><li><strong>环境变量</strong>，配置可以预置在操作系统的环境变量里头，程序运行时读取，这是很多PaaS平台，比如Heroku推荐的做法，参考12 factor app[附录8.1]。</li><li><strong>启动参数</strong>，可以在程序启动时一次性提供参数，例如java程序启动时可以通过<code>java -D</code>方式配启动参数。</li><li><strong>基于数据库</strong>，有经验的开发人员会把易变配置放在数据库中，这样可以在运行期灵活调整配置，这个做法和配置中心的思路已经有点接近了。</li></ul><p><img src="/images/2018060701/config_format.png" alt="config foramt"></p><h3 id="二、传统应用配置的痛点"><a href="#二、传统应用配置的痛点" class="headerlink" title="二、传统应用配置的痛点"></a>二、传统应用配置的痛点</h3><p>在没有引入配置中心之前，一般企业研发都会面临如下痛点：</p><h4 id="1-配置散乱格式不标准"><a href="#1-配置散乱格式不标准" class="headerlink" title="1. 配置散乱格式不标准"></a><strong>1. 配置散乱格式不标准</strong></h4><p>有的用properties格式，有的用xml格式，还有的存DB，团队倾向自造轮子，做法五花八门。</p><h4 id="2-主要采用本地静态配置，配置修改麻烦"><a href="#2-主要采用本地静态配置，配置修改麻烦" class="headerlink" title="2. 主要采用本地静态配置，配置修改麻烦"></a><strong>2. 主要采用本地静态配置，配置修改麻烦</strong></h4><p>配置修改一般需要经过一个较长的测试发布周期。在分布式微服务环境下，当服务实例很多时，修改配置费时费力。</p><h4 id="3-易引发生产事故"><a href="#3-易引发生产事故" class="headerlink" title="3. 易引发生产事故"></a><strong>3. 易引发生产事故</strong></h4><p>这个是我亲身经历，之前在一家互联网公司，有团队在发布的时候将测试环境的配置带到生产上，引发百万级资损事故。</p><h4 id="4-配置缺乏安全审计和版本控制功能"><a href="#4-配置缺乏安全审计和版本控制功能" class="headerlink" title="4. 配置缺乏安全审计和版本控制功能"></a><strong>4. 配置缺乏安全审计和版本控制功能</strong></h4><p>谁改的配置？改了什么？什么时候改的？无从追溯，出了问题也无法及时回滚。</p><h3 id="三、现代应用配置核心需求"><a href="#三、现代应用配置核心需求" class="headerlink" title="三、现代应用配置核心需求"></a>三、现代应用配置核心需求</h3><p>近年，持续交付和DevOps理念开始逐步被一线企业接受，微服务架构和容器云也逐渐在一线企业落地，这些都对应用配置管理提出了更高的要求：</p><p><img src="/images/2018060701/core_requirements.png" alt="core requirement"></p><h4 id="1-交付件和配置分离"><a href="#1-交付件和配置分离" class="headerlink" title="1. 交付件和配置分离"></a><strong>1. 交付件和配置分离</strong></h4><p>传统做法应用在打包部署时，会为不同环境打出不同配置的包，例如为开发/测试/UAT/生产环境分别制作发布包，每个包里头包含环境特定配置。</p><p>现代微服务提倡云原生(Cloud Native)和不可变基础设施（Immutable Infrastructure）的理念，推荐采用如容器镜像这种方式打包和交付微服务，应用镜像一般只打一份，可以部署到不同环境。这就要求交付件（比如容器镜像）和配置进行分离，交付件只制作一份，并且是不可变的，可以部署到任意环境，而配置由配置中心集中管理，所有环境的配置都可以在配置中心集中配，运行期应用根据自身环境到配置中心动态拉取相应的配置。</p><h4 id="2-抽象标准化"><a href="#2-抽象标准化" class="headerlink" title="2. 抽象标准化"></a><strong>2. 抽象标准化</strong></h4><p>企业应该由框架或者中间件团队提供标准化的配置中心服务(Configuration as a Service)，封装屏蔽配置管理的细节和配置的不同格式，方便用户进行自助式的配置管理。一般用户只需要关注两个抽象和标准化的接口：</p><ol><li>配置管理界面UI，方便应用开发人员管理和发布配置，</li><li>封装好的客户端API，方便应用集成和获取配置。</li></ol><h4 id="3-多环境多集群"><a href="#3-多环境多集群" class="headerlink" title="3. 多环境多集群"></a><strong>3. 多环境多集群</strong></h4><p>现代微服务应用大都采用多环境部署，一般标准化的环境有开发/测试/UAT/生产等，有些应用还需要多集群部署，例如支持跨机房或者多版本部署。配置中心需要支持对多环境和多集群应用配置的集中式管理。</p><h4 id="4-高可用"><a href="#4-高可用" class="headerlink" title="4. 高可用"></a><strong>4. 高可用</strong></h4><p>配置中心必须保证高可用，不能随便挂，否则可能大面积影响微服务。在极端的情况下，如果配置中心不可用，客户端也需要有降级策略，保证应用可以不受影响。</p><h4 id="5-实时性"><a href="#5-实时性" class="headerlink" title="5. 实时性"></a><strong>5. 实时性</strong></h4><p>配置更新需要尽快通知到客户端，这个周期不能太长，理想应该是实时的。有些配置的实时性要求很高，比方说主备切换配置或者蓝绿部署配置，需要秒级切换配置的能力。</p><h4 id="6-治理"><a href="#6-治理" class="headerlink" title="6. 治理"></a><strong>6. 治理</strong></h4><p>配置需要治理，具体包括：</p><ul><li>配置审计，谁、在什么时间、修改了什么配置，需要详细的审计，方便出现问题时能够追溯。</li><li>配置版本控制，每次变更需要版本化，出现问题时候能够及时回滚到上一版本。</li><li>配置权限控制，配置变更发布需要认证授权，不是所有人都能修改和发布配置。</li><li>灰度发布，高级的配置治理支持灰度发布，配置发布时可以先让少数实例生效，确保没有问题再逐步放量。</li></ul><h3 id="四、配置分类"><a href="#四、配置分类" class="headerlink" title="四、配置分类"></a>四、配置分类</h3><p>配置目前还没有特别标准的分类方法，我简单把配置分为静态和动态两大类，每一类再分为若干子类，如下图：</p><p><img src="/images/2018060701/config_category.png" alt="config category"></p><h4 id="1-静态配置"><a href="#1-静态配置" class="headerlink" title="1. 静态配置"></a><strong>1. 静态配置</strong></h4><p>所谓静态配置，就是在程序启动前一次性配好，启动时一次性生效，在程序运行期一般不会变化的配置。具体包括：</p><h5 id="1-1-环境相关配置"><a href="#1-1-环境相关配置" class="headerlink" title="1.1 环境相关配置"></a>1.1 环境相关配置</h5><p>有些配置是和环境相关的，每个环境的配置不一样，例如数据库、中间件和其它服务的连接字符串配置。这些配置一次性配好，运行期一般不变。</p><h5 id="1-2-安全配置"><a href="#1-2-安全配置" class="headerlink" title="1.2 安全配置"></a>1.2 安全配置</h5><p>有些配置和安全相关，例如用户名，密码，访问令牌，许可证书等，这些配置也是一次性配好，运行期一般不变。因为涉及安全，相关信息一般需要加密存储，对配置访问需要权限控制。</p><h4 id="2-动态配置"><a href="#2-动态配置" class="headerlink" title="2. 动态配置"></a><strong>2. 动态配置</strong></h4><p>所谓动态配置，就是在程序的运行期可以根据需要动态调整的配置。动态配置让应用行为和功能的调整变得更加灵活，是持续交付和DevOps的最佳实践。具体包括：</p><h5 id="2-1-应用配置"><a href="#2-1-应用配置" class="headerlink" title="2.1 应用配置"></a>2.1 应用配置</h5><p>和应用相关的配置，例如服务请求超时，线程池和队列的大小，缓存过期时间，数据库连接池的容量，日志输出级别，限流熔断阀值，服务安全黑白名单等。一般开发或者运维会根据应用的实际运行情况调整这些配置。</p><h5 id="2-2-业务配置"><a href="#2-2-业务配置" class="headerlink" title="2.2 业务配置"></a>2.2 业务配置</h5><p>和业务相关的一些配置，例如促销规则，贷款额度，利率等业务参数，A/B测试参数等。一般产品运营或开发人员会根据实际的业务需求，动态调整这些参数。</p><h5 id="2-3-功能开关"><a href="#2-3-功能开关" class="headerlink" title="2.3 功能开关"></a>2.3 功能开关</h5><p>在英文中也称Feature Flag/Toggle/Switch，简单的只有真假两个值，复杂的可以是多值参数。功能开关是DevOps的一种最佳实践，在运维中有很多应用场景，比如蓝绿部署，灰度开关，降级开关，主备切换开关，数据库迁移开关等。功能开关在国外互联网公司用得比较多，国内还没有普及开，所以我在下一节会给出一些功能开关的高级应用场景。</p><h3 id="五、配置中心高级应用场景"><a href="#五、配置中心高级应用场景" class="headerlink" title="五、配置中心高级应用场景"></a>五、配置中心高级应用场景</h3><h4 id="场景一、蓝绿部署"><a href="#场景一、蓝绿部署" class="headerlink" title="场景一、蓝绿部署"></a>场景一、蓝绿部署</h4><p>蓝绿部署的传统做法是通过负载均衡器切流量来实现，如下图左边所示。这种做法一般研发人员无法自助操作，需要提交工单由运维介入操作，操作和反馈周期比较长，出了问题回退还需运维人员介入，所以回退也比较慢，总体风险比较高。</p><p><img src="/images/2018060701/blue_green_deployment.png" alt="blue greeen deployment"></p><p>蓝绿部署也可以通过配置中心+功能开关的方式来实现，如上图右边所示。开发人员在上线新功能时先将新功能隐藏在动态开关后面，开关的值在配置中心里头配。刚上线时新功能暂不启用，走老功能逻辑，然后开发人员通过配置中心打开开关，这个时候新功能就启用了。一旦发现新功能有问题，可以随时把开关关掉切回老功能。这种做法开发人员可以全程自助实现蓝绿部署，不需要运维人员介入，反馈周期短效率高。</p><h4 id="场景二、限流降级"><a href="#场景二、限流降级" class="headerlink" title="场景二、限流降级"></a>场景二、限流降级</h4><p>当业务团队在搞促销，或者是系统受DDOS攻击的时候，如果没有好的限流降级机制，则系统很容易被洪峰流量冲垮，这个时候所有用户无法访问，体验糟糕，如下图左边所示。</p><p><img src="/images/2018060701/rate_limiting_degrade.png" alt="rate limiting and degrade"></p><p>所以我们需要限流降级机制来应对流量洪峰。常见做法，我们一般会在应用的过滤器层或者是网关代理层添加限流降级逻辑，并且和配置中心配合，实现限流降级开关和参数的动态调整。如果促销出现流量洪峰，我们可以通过配置中心启动限流降级策略，比如对于普通用户，我们可以先给出“网络不给力，请稍后再试”的友好提示，对于高级VIP用户，我们仍然保证他们的正常访问。</p><p>国内电商巨头阿里，它内部的系统大量采用限流降级机制，实现方式基于其内部的diamond+sentinel配置管理系统。如果没有限流降级机制的保护，则阿里的系统也无法抵御双十一带来的洪峰流量冲击。</p><h4 id="场景三、数据库迁移"><a href="#场景三、数据库迁移" class="headerlink" title="场景三、数据库迁移"></a>场景三、数据库迁移</h4><p>LaunchDarkly是一家提供配置既服务(Configuration as a Service)的SAAS服务公司，它在其博客上给出了一片关于使用功能开关实现数据库迁移的案例文章，该案例基于其内部一次成功的数据库迁移实践，从MongdoDB迁移到DynamoDB[参考附录8.2]，下图是展示了一个简化的迁移流程：</p><p><img src="/images/2018060701/ff_database_migration-768x1024.jpg" alt="database migration using feature flag"></p><p>简化迁移腾挪流程如下：</p><ol><li>开发人员先在应用端的DAO层埋好数据双写双读、以及数据比对逻辑。双写双读逻辑由开关控制，开关的值可在配置中心配。</li><li>先保证应用100%读写mongoDB，然后先放开10%的DynamoDB双写，也称金丝雀写(Canary Write)，确保金丝雀写没有功能和性能问题。</li><li>逐步放量DyanamoDB写到100%，确保全量双写没有功能和性能问题。</li><li>放开10%的DynamoDB双读，也称金丝雀读(Canary Read)，通过比对逻辑确保金丝雀读没有逻辑和性能问题。</li><li>逐步放量DynamoDB读到100%，通过比对逻辑确保全量双读没有逻辑和性能问题。</li><li>关闭对mongoDB的读写，迁移完成。</li></ol><p>整个迁移流程受配置中心的开关控制，可以灵活调整开关和参数，有问题可以随时回滚，大大降低迁移风险。</p><h4 id="场景四、A-B测试"><a href="#场景四、A-B测试" class="headerlink" title="场景四、A/B测试"></a>场景四、A/B测试</h4><p>如果我们需要对电商平台的结账(checkout)功能进行改版，考虑到结账功能业务影响面大，一下子上线风险大，为了减低风险，我们可以在配置中心配合下，对结账功能进行A/B测试，简化逻辑如下图：</p><p><img src="/images/2018060701/ab_test.png" alt="ab test"></p><p>我们在配置中心中增加一个<code>ab_test_flag</code>开关，控制A/B测试逻辑：</p><ol><li>如果A/B测试开关是关闭的(<code>ab_test_flag==false</code>)，那么就走老的结账逻辑。</li><li>如果A/B测试开关是打开的(<code>ab_test_flag==true</code>，并且是普通用户(<code>user==regular</code>，可以检查数据库中用户类型)，那么就走老的结账逻辑。</li><li>如果A/B测试开关是打开的(<code>ab_test_flag==true</code>)，并且是beta用户（<code>user==beta</code>），那么就走改版后的新结账逻辑。</li></ol><p>通过配置中心，我们可以灵活调整开关，先对新功能进行充分的beta试验，再考虑全量上线，大大降低关键业务新功能的上线风险。</p><h3 id="六、公司案例和产品"><a href="#六、公司案例和产品" class="headerlink" title="六、公司案例和产品"></a>六、公司案例和产品</h3><p>在一线前沿的互联网公司，配置中心都是其技术体系中的关键基础服务，下图给出一些公司案例产品：</p><p><img src="/images/2018060701/config_center_products.png" alt="config center products"></p><ol><li>阿里巴巴中间件部门很早就自研了配置中心Diamond，并且是开源的。Diamond对阿里系统的灵活稳定性发挥了至关重要的作用。开源版本的Diamond由于研发时间比较早，使用的技术比较老，功能也不够完善，目前社区不热已经不维护了。</li><li>Facebook内部也有一整套完善的配置管理体系[可参考其论文，附录8.3]，其中一个产品叫Gatekeeper，目前没有开源。</li><li>Netflix内部有大量的微服务，它的服务的稳定灵活性也重度依赖于配置中心。Netflix开源了它的配置中心的客户端，叫变色龙Archaius[参考附录8.4]，比较可惜的是，Netflix没有开源它的配置中心的服务器端。</li><li>Apollo[参考附录8.5]是携程框架部研发并开源的一款配置中心产品，企业级治理功能完善，目前社区比较火，在github上有超过5k星，在国内众多互联网公司有落地案例。<strong>如果企业打算引入开源的配置中心，那么Apollo是我推荐的首选</strong>。</li><li>百度之前也开源过一个叫Disconf[参考附录8.6]的配置中心产品，作者是前百度资深工程师廖绮绮。在Apollo没有出来之前，Disconf在社区是比较火的，但是自从廖琦琦离开百度之后，他好像没有足够精力投入维护这个项目，目前社区活跃度已经大不如前。</li></ol><h3 id="七、结论"><a href="#七、结论" class="headerlink" title="七、结论"></a>七、结论</h3><ol><li>配置中心是微服务基础架构中不可或缺的核心组件，现代微服务架构和云原生环境，对应用配置管理提出了更高的要求。</li><li>配置中心有众多的应用场景，配置中心+功能开关是DevOps最佳实践。用好配置中心，它能帮助技术组织实现持续交付和DevOps文化转型。</li><li>携程开源的Apollo配置中心，企业级功能完善，经过大规模生产验证，社区活跃度高，是开源配置中心产品的首选。</li><li>波波近期和极客时间合作，推出《微服务架构实践160讲》视频课程，<strong>其中第二模块会对微服务配置中心Apollo的架构和实践进行深度剖析</strong>，欢迎大家关注。</li></ol><h3 id="八、附录"><a href="#八、附录" class="headerlink" title="八、附录"></a>八、附录</h3><ol><li><p><a href="https://12factor.net/config" target="_blank" rel="noopener">12 Factor App</a></p></li><li><p><a href="https://blog.launchdarkly.com/feature-flagging-to-mitigate-risk-in-database-migration/" target="_blank" rel="noopener">使用功能开关实现数据库迁移</a></p></li><li><p><a href="http://sigops.org/sosp/sosp15/current/2015-Monterey/printable/008-tang.pdf" target="_blank" rel="noopener">Facebook的配置管理体系论文</a></p></li><li><p><a href="https://github.com/Netflix/archaius" target="_blank" rel="noopener">Netflix开源的Archaius配置库</a></p></li><li><p><a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">携程开源的Apollo配置中心</a></p></li><li><p><a href="https://github.com/knightliao/disconf" target="_blank" rel="noopener">Disconf配置中心</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;在系统架构中，和安全、日志、监控等非功能需求一样，配置管理也是一种非功能需求。配置中心是整个微服务基础架构体系中的一个组件，如下图，它的功能看上去并不起眼，无非就是简单配置的管理和存取，但它是整个微服务架构中不可或缺的一环。另外，配置中心如果真得用好了，它还能推动技术组织持续交付和DevOps文化转型。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务架构" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
      <category term="配置中心" scheme="http://yoursite.com/tags/%E9%85%8D%E7%BD%AE%E4%B8%AD%E5%BF%83/"/>
    
  </entry>
  
  <entry>
    <title>微服务2.0技术栈选型手册</title>
    <link href="http://yoursite.com/2018/05/29/2018052902/"/>
    <id>http://yoursite.com/2018/05/29/2018052902/</id>
    <published>2018-05-29T03:00:26.000Z</published>
    <updated>2018-06-15T11:37:56.871Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>2014年可以认为是微服务1.0的元年，当年有几个标志性事件，一是Martin Fowler在其博客上发表了“Microservices”一文，正式提出微服务架构风格；二是Netflix微服务架构经过多年大规模生产验证，最终抽象落地形成一整套开源的微服务基础组件，统称NetflixOSS，Netflix的成功经验开始被业界认可并推崇；三是Pivotal将NetflixOSS开源微服务组件集成到其Spring体系，推出Spring Cloud微服务开发技术栈。</p><p>一晃三年过去，微服务技术生态又发生了巨大变化，容器，PaaS，Cloud Native，gRPC，ServiceMesh，Serverless等新技术新理念你方唱罢我登场，不知不觉我们又来到了微服务2.0时代。基于近年在微服务基础架构方面的实战经验和平时的学习积累，我想总结并提出一些构建微服务2.0技术栈的选型思路，供各位在一线实战的架构师、工程师参考借鉴。对于一些暂时还没有成熟开源产品的微服务支撑模块，我也会给出一些定制自研的设计思路。</p><a id="more"></a><h3 id="一、选型准侧"><a href="#一、选型准侧" class="headerlink" title="一、选型准侧"></a>一、选型准侧</h3><p>对于技术选型，我个人有很多标准，其中下面三项是最重要的:</p><h4 id="1-生产级"><a href="#1-生产级" class="headerlink" title="1. 生产级"></a>1. 生产级</h4><p>我们选择的技术栈是要解决实际业务问题和上生产抗流量的（选择不慎可能造成生产级事故），而不是简单做个POC或者Demo展示，所以生产级（Production Ready），可运维（Ops Ready），可治理，成熟稳定的技术才是我们的首选；</p><h4 id="2-一线互联网公司落地产品"><a href="#2-一线互联网公司落地产品" class="headerlink" title="2. 一线互联网公司落地产品"></a>2. 一线互联网公司落地产品</h4><p>我们会尽量采用在一线互联网公司落地并且开源的，且在社区内形成良好口碑的产品，它们已经在这些公司经过流量冲击，坑已经基本被填平，且被社区接受形成一个良好的社区生态（本文附录部分会给出所有推荐使用或参考的开源项目的github链接。）。</p><h4 id="3-开源社区活跃度"><a href="#3-开源社区活跃度" class="headerlink" title="3. 开源社区活跃度"></a>3. 开源社区活跃度</h4><p>Github上的stars的数量是一个重要指标，同时会参考其代码和文档更新频率（尤其是近年），这些指标直接反应开源产品的社区活跃度或者说生命力。</p><p>另外，对于不同业务体量和团队规模的公司，技术选型标准往往是不同的，创业公司的技术选型和BAT级别公司的技术选型标准可能完全不同。本文主要针对日流量千万以上，研发团队规模不少于50人的公司，如果小于这个规模我建议认真评估是否真的需要采用微服务架构。考虑到Java语言在国内的流行度和我个人的背景经验，本文主要针对采用Java技术栈的企业。本文也假定自建微服务基础架构，有些产品其实有对应的云服务可以直接使用，自建和采用云服务各有利弊，架构师需要根据场景上下文综合权衡。</p><h3 id="二、微服务基础架构核心关心点"><a href="#二、微服务基础架构核心关心点" class="headerlink" title="二、微服务基础架构核心关心点"></a>二、微服务基础架构核心关心点</h3><p>下面脑图中芒果色标注的七个模块，我认为是构建微服务2.0技术栈的核心模块，本文后面的选型会分别基于这些模块展开。对于每个模块我也列出一些核心架构关注点，在选择具体产品时，需要尽可能覆盖到这些关注点。</p><p><img src="/images/2018052902/msa_arch.png" alt="msa arch"></p><p>下图是在参考过华为技术专家王磊的《微服务的设计与生态系统》[附录11.46]的基础上，结合作者自身的实践调整而来，我想同时分享给一线架构师或者工程师参考，其中粉红色标注的模块是和微服务关系最密切的模块，大家在做技术选型时，可以同时对照这个体系。</p><p><img src="/images/2018052902/msa_system.png" alt="msa system"></p><h3 id="三、服务框架选型"><a href="#三、服务框架选型" class="headerlink" title="三、服务框架选型"></a>三、服务框架选型</h3><p>服务框架是一个比较成熟的领域，有太多可选项。<strong>Spring Boot/Cloud</strong>[附录11.1]由于Spring社区的影响力和Netflix的背书，目前可以认为是构建Java微服务的一个社区标准，Spring Boot目前在github上有超过20k星。基于Spring的框架本质上可以认为是一种RESTful框架（不是RPC框架），序列化协议主要采用基于文本的JSON，通讯协议一般基于HTTP。RESTful框架天然支持跨语言，任何语言只要有HTTP客户端都可以接入调用，但是客户端一般需要自己解析payload。目前Spring框架也支持Swagger契约编程模型，能够基于契约生成各种语言的强类型客户端，极大方便不同语言栈的应用接入，但是因为RESTful框架和Swagger规范的弱契约特性，生成的各种语言客户端的互操作性还是有不少坑的。</p><p><strong>Dubbo</strong>[附录11.2]是阿里多年构建生产级分布式微服务的技术结晶，服务治理能力非常丰富，在国内技术社区具有很大影响力，目前github上有超过16k星。Dubbo本质上是一套基于Java的RPC框架，当当Dubbox扩展了Dubbo支持RESTful接口暴露能力。Dubbo主要面向Java 技术栈，跨语言支持不足是它的一个弱项，另外因为治理能力太丰富，以至于这个框架比较重，完全用好这个框架的门槛比较高，但是如果你的企业基本上投资在Java技术栈上，选Dubbo可以让你在服务框架一块站在较高的起点上，不管是性能还是企业级的服务治理能力，Dubbo都做的很出色。新浪微博开源的Motan（github 4k stars）也不错，功能和Dubbo类似，可以认为是一个轻量裁剪版的Dubbo。</p><p><strong>gRPC</strong>[附录11.3]是谷歌近年新推的一套RPC框架，基于protobuf的强契约编程模型，能自动生成各种语言客户端，且保证互操作。支持HTTP2是gRPC的一大亮点，通讯层性能比HTTP有很大改进。Protobuf是在社区具有悠久历史和良好口碑的高性能序列化协议，加上Google公司的背书和社区影响力，目前gRPC也比较火，github上有超过13.4k星。目前看gRPC更适合内部服务相互调用场景，对外暴露HTTP RESTful接口可以实现，但是比较麻烦（需要gRPC Gateway配合），所以对于对外暴露API场景可能还需要引入第二套HTTP RESTful框架作为补充。总体上gRPC这个东西还比较新，社区对于HTTP2带来的好处还未形成一致认同，建议谨慎投入，可以做一些试点。</p><h3 id="四、运行时支撑服务选型"><a href="#四、运行时支撑服务选型" class="headerlink" title="四、运行时支撑服务选型"></a>四、运行时支撑服务选型</h3><p>运行时支撑服务主要包括服务注册中心，服务路由网关和集中式配置中心三个产品。</p><p><strong>服务注册中心</strong>，如果采用Spring Cloud体系，则选择<strong>Eureka</strong>[附录11.4]是最佳搭配，Eureka在Netflix经过大规模生产验证，支持跨数据中心，客户端配合Ribbon可以实现灵活的客户端软负载，Eureka目前在github上有超过4.7k星；<strong>Consul</strong>[附录11.5]也是不错选择，天然支持跨数据中心，还支持KV模型存储和灵活健康检查能力，目前在github上有超过11k星。</p><p><strong>服务网关</strong>也是一个比较成熟的领域，有很多可选项。如果采用Spring Cloud体系，则选择<strong>Zuul</strong>[附录11.6]是最佳搭配，Zuul在Netflix经过大规模生产验证，支持灵活的动态过滤器脚本机制，异步性能不足（基于Netty的异步Zuul迟迟未能推出正式版）。Zuul网关目前在github上有超过3.7k星。基于Nginx/OpenResty的API网关<strong>Kong</strong>[附录11.7]目前在github上比较火，有超过14.1k星。因为采用Nginx内核，Kong的异步性能较强，另外基于lua的插件机制比较灵活，社区插件也比较丰富，从安全到限流熔断都有，还有不少开源的管理界面，能够集中管理Kong集群。</p><p><strong>配置中心</strong>，Spring Cloud自带<strong>Spring Cloud Config</strong>[附录11.8]（github 0.75k stars），个人认为算不上生产级，很多治理能力缺失，小规模场景可以试用。个人比较推荐携程的<strong>Apollo</strong>[附录11.9]配置中心，在携程经过生产级验证，具备高可用，配置实时生效（推拉结合），配置审计和版本化，多环境多集群支持等生产级特性，建议中大规模需要对配置集中进行治理的企业采用。Apollo目前在github上有超过3.4k星。</p><h3 id="五、服务监控选型"><a href="#五、服务监控选型" class="headerlink" title="五、服务监控选型"></a>五、服务监控选型</h3><p>主要包括日志监控，调用链监控，Metrics监控，健康检查和告警通知等产品。</p><p><strong>ELK</strong>目前可以认为是日志监控的标配，功能完善开箱即用，<strong>Elasticsearch</strong>[附录11.10]目前在github上有超过28.4k星。<strong>Elastalert</strong>[附录11.11] (github 4k stars)是Yelp开源的针对ELK的告警通知模块。</p><p>调用链监控目前社区主流是点评<strong>CAT</strong>[附录11.12]（github 4.3k stars），Twitter之前开源现在由OpenZipkin社区维护的<strong>Zipkin</strong>[附录11.13]（github 7.5k stars）和Naver开源的<strong>Pinpoint</strong>[附录11.14]（github 5.3k stars）。个人比较推荐点评开源的CAT，在点评和国内多家互联网公司有落地案例，生产级特性和治理能力较完善，另外CAT自带告警模块。下面是我之前对三款产品的评估表，供参考。</p><p><img src="/images/2018052902/monitoring_evaluation.png" alt="monitoring evaluation"></p><p>Metrics监控主要依赖于时间序列数据库(TSDB)，目前较成熟的产品是StumbleUpon公司开源的基于HBase的<strong>OpenTSDB</strong>[附录11.15]（基于Cassandra的<strong>KariosDB</strong>[附录11.16]也是一个选择，github 1.1k stars，它基本上是OpenTSDB针对Cassandra的一个改造版），OpenTSDB具有分布式能力可以横向扩展，但是相对较重，适用于中大规模企业，OpenTSDB目前在github上有近2.9k星。OpenTSDB 本身不提供告警模块，<strong>Argus</strong>[附录11.17]（github 0.29k星）是Salesforce开源的基于OpenTSDB的统一监控告警平台，支持丰富的告警函数和灵活的告警配置，可以作为OpenTSDB的告警补充。近年也出现一些轻量级的TSDB，如<strong>InfluxDB</strong>[附录11.18]（github 12.4k stars）和<strong>Prometheus</strong>[附录11.19]（github 14.3k stars），这些产品函数报表能力丰富，自带告警模块，但是分布式能力不足，适用于中小规模企业。<strong>Grafana</strong>[附录11.20]（github 19.9k stars）是Metrics报表展示的社区标配。</p><p>社区还有一些通用的健康检查和告警产品，例如<strong>Sensu</strong>[附录11.21]（github 2.7k stars），能够对各种服务（例如spring boot暴露的健康检查端点，时间序列数据库中的metrics，ELK中的错误日志等）定制灵活的健康检查(check)，然后用户可以针对check结果设置灵活的告警通知策略。Sensu在Yelp等公司有落地案例。其它类似产品还有Esty开源的<strong>411</strong>[附录11.22]（github 0.74k星）和Zalando的<strong>ZMon</strong>[附录11.23] (github 0.15k星)，它们是分别在Esty和Zalando落地的产品，但是定制check和告警配置的使用门槛比较高，社区不热，建议有定制自研能力的团队试用。ZMon后台采用KairosDB存储，如果企业已经采用KariosDB作为时间序列数据库，则可以考虑ZMon作为告警通知模块。</p><h3 id="六、服务容错选型"><a href="#六、服务容错选型" class="headerlink" title="六、服务容错选型"></a>六、服务容错选型</h3><p>针对Java技术栈，Netflix的<strong>Hystrix</strong>[附录11.24]（github 12.4k stars）把熔断、隔离、限流和降级等能力封装成组件，任何依赖调用（数据库，服务，缓存）都可以封装在Hystrix Command之内，封装后自动具备容错能力。Hystrix起源于Netflix的弹性工程项目，经过Netflix大规模生产验证，目前是容错组件的社区标准，github上有超12k星。其它语言栈也有类似Hystrix的简化版本组件。</p><p>Hystrix一般需要在应用端或者框架内埋点，有一定的使用门槛。对于采用集中式反向代理（边界和内部）做服务路由的公司，则可以集中在反向代理上做熔断限流，例如采用<strong>nginx</strong>[附录11.25]（github 5.1k stars）或者<strong>Kong</strong>[附录11.7]（github 11.4k stars）这类反向代理，它们都有插件支持灵活的限流容错配置。Zuul网关也可以集成Hystrix实现网关层集中式限流容错。集中式反向代理需要有一定的研发和运维能力，但是可以对限流容错进行集中治理，可以简化客户端。</p><h3 id="七、后台服务选型"><a href="#七、后台服务选型" class="headerlink" title="七、后台服务选型"></a>七、后台服务选型</h3><p>后台服务主要包括消息系统，分布式缓存，分布式数据访问层和任务调度系统。后台服务是一个相对比较成熟的领域，很多开源产品基本可以开箱即用。</p><p><strong>消息系统</strong>，对于日志等可靠性要求不高的场景，则Apache顶级项目<strong>Kafka</strong>[附录11.26]（github 7.2k stars）是社区标配。对于可靠性要求较高的业务场景，kafka其实也是可以胜任，但企业需要根据具体场景，对 Kafka的监控和治理能力进行适当定制完善，Allegro公司开源的<strong>hermes</strong>[附录11.27]（github 0.3k stars）是一个可参考项目，它在Kafka基础上封装了适合业务场景的企业级治理能力。阿里开源的<strong>RocketMQ</strong>[附录11.28]（github 3.5k星）也是一个不错选择，具备更多适用于业务场景的特性，目前也是Apache顶级项目。<strong>RabbitMQ</strong>[附录11.29]（github 3.6k星）是老牌经典的MQ，队列特性和文档都很丰富，性能和分布式能力稍弱，中小规模场景可选。</p><p>对于<strong>缓存治理</strong>，如果倾向于采用客户端直连模式（个人认为缓存直连更简单轻量），则SohuTv开源的<strong>cachecloud</strong>[附录11.30]（github 2.5k stars）是一款不错的Redis缓存治理平台，提供诸如监控统计，一键开启，自动故障转移，在线伸缩，自动化运维等生产级治理能力，另外其文档也比较丰富。如果倾向采用中间层Proxy模式，则Twitter开源的<strong>twemproxy</strong>[附录11.31]（github 7.5k stars）和CodisLab开源的<strong>codis</strong>[附录11.32]（github 6.9k stars）是社区比较热的选项。</p><p>对于<strong>分布式数据访问层</strong>，如果采用Java技术栈，则当当开源的<strong>shardingjdbc</strong>[附录11.33]（github 3.5k stars）是一个不错的选项，分库分表逻辑做在客户端jdbc driver中，客户端直连数据库比较简单轻量，建议中小规模场景采用。如果倾向采用数据库访问中间层proxy模式，则从阿里Cobar演化出来的社区开源分库分表中间件<strong>MyCAT</strong>[附录11.34]（github 3.6k stars）是一个不错选择 。proxy模式运维成本较高，建议中大规模场景，有一定框架自研和运维能力的团队采用。</p><p><strong>任务调度系统</strong>，个人推荐徐雪里开源的<strong>xxl-job</strong>[附录11.35]（github 3.4k stars），部署简单轻量，大部分场景够用。当当开源的<strong>elastic-job</strong>[附录11.36]（github 3.2k stars）也是一个不错选择，相比xxl-job功能更强一些也更复杂。</p><h3 id="八、服务安全选型"><a href="#八、服务安全选型" class="headerlink" title="八、服务安全选型"></a>八、服务安全选型</h3><p>对于微服务安全认证授权机制一块，目前业界虽然有OAuth和OpenID connect等标准协议，但是各家具体实现的做法都不太一样，企业一般有很多特殊的定制需求，整个社区还没有形成通用生产级开箱即用的产品。有一些开源授权服务器产品，比较知名的如<strong>Apereo CAS</strong>[附录11.37]（github 3.6k stars），JBoss开源的<strong>keycloak</strong>[附录11.38]（github 1.9 stars），<strong>spring cloud security</strong>[附录11.39]等，大都是opinionated（一家观点和做法）的产品，同时因支持太多协议造成产品复杂，也缺乏足够灵活性。个人建议基于OAuth和OpenID connect标准，在参考一些开源产品的基础上（例如Mitre开源的<strong>OpenID-Connect-Java-Spring-Server</strong>[附录11.40]，github 0.62k stars），定制自研轻量级授权服务器。Wso2提出了一种微服务安全的参考方案[附录11.45]，建议参考，该方案的关键步骤如下：</p><p><img src="/images/2018052902/msa_security.png" alt="msa security"></p><ol><li>使用支持OAuth 2.0和OpenID Connect标准协议的授权服务器（个人建议定制自研）；</li><li>使用API网关作为单一访问入口，统一实现安全治理；</li><li>客户在访问微服务之前，先通过授权服务器登录获取access token，然后将access token和请求一起发送到网关；</li><li>网关获取access token，通过授权服务器校验token，同时做token转换获取JWT token。</li><li>网关将JWT Token和请求一起转发到后台微服务；</li><li>JWT中可以存储用户会话信息，该信息可以传递给后台的微服务，也可以在微服务之间传递，用作认证授权等用途；</li><li>每个微服务包含JWT客户端，能够解密JWT并获取其中的用户会话信息。</li><li>整个方案中，access token是一种by reference token，不包含用户信息可以直接暴露在公网上；JWT token是一种by value token，可以包含用户信息但不暴露在公网上。</li></ol><h3 id="九、服务部署平台选型"><a href="#九、服务部署平台选型" class="headerlink" title="九、服务部署平台选型"></a>九、服务部署平台选型</h3><p>容器已经被社区接受为交付微服务的一种理想手段，可以实现不可变（immutable）发布模式。一个轻量级的基于容器的服务部署平台主要包括容器资源调度，发布系统，镜像治理，资源治理和IAM等模块。</p><p><strong>集群资源调度系统</strong>：屏蔽容器细节，将整个集群抽象成容器资源池，支持按需申请和释放容器资源，物理机发生故障时能够实现自动故障迁移(fail over)。目前Google开源的<strong>kubernetes</strong>[附录11.41]，在Google背书和社区的强力推动下，基本已经形成市场领导者地位，github上有31.8k星，社区的活跃度已经远远超过了<strong>mesos</strong>[附录11.42]（github 3.5k stars）和swarm等竞争产品，所以容器资源调度建议首选k8s。当然如果你的团队有足够定制自研能力，想深度把控底层调度算法，也可以基于mesos做定制自研。</p><p><strong>镜像治理</strong>：基于docker registry，封装一些轻量级的治理功能。vmware开源的harbor[附录11.43] (github 3.5k stars)是目前社区比较成熟的企业级产品，在docker registry基础上扩展了权限控制，审计，镜像同步，管理界面等治理能力，可以考虑采用。</p><p><strong>资源治理</strong>：类似于CMDB思路，在容器云环境中，企业仍然需要对应用app，组织org，容器配额和数量等相关信息进行轻量级的治理。目前这块还没有生产级的开源产品，一般企业需要根据自己的场景定制自研。</p><p><strong>发布平台</strong>：面向用户的发布管理控制台，支持发布流程编排。它和其它子系统对接交互，实现基本的应用发布能力，也实现如蓝绿，金丝雀和灰度等高级发布机制。目前这块生产级的开源产品很少，Netflix开源的<strong>spinnaker</strong>[附录11.44]（github 4.2k stars）是一个，但是这个产品比较复杂重量（因为它既要支持适配对接各种CI系统，同时还要适配对接各种公有云和容器云，使得整个系统异常复杂），一般企业建议根据自己的场景定制自研轻量级的解决方案。</p><p><strong>IAM</strong>：是identity &amp; access management的简称，对发布平台各个组件进行身份认证和安全访问控制。社区有不少开源的IAM产品，比较知名的有<strong>Apereo CAS</strong>（github 3.6k stars），JBoss开源的<strong>keycloak（github 1.9 stars）</strong>等。但是这些产品一般都比较复杂重量，很多企业考虑到内部各种系统灵活对接的需求，都会考虑定制自研轻量级的解决方案。</p><p>考虑到服务部署平台目前还没有端到端生产级解决方案，企业一般需要定制集成，下面给出一个可以参考的具备轻量级治理能努力的发布体系：</p><p><img src="/images/2018052902/deployment_system.png" alt="deployment system"></p><p>简化发布流程如下：</p><ol><li>应用通过CI集成后生成镜像，用户将镜像推到镜像治理中心；</li><li>用户在资产治理中心申请发布，填报应用，发布和配额相关信息，然后等待审批通过；</li><li>发布审批通过，开发人员通过发布控制台发布应用；</li><li>发布系统通过查询资产治理中心获取发布规格信息；</li><li>发布系统向容器云发出启动容器实例指令；</li><li>容器云从镜像治理中心拉取镜像并启动容器；</li><li>容器内服务启动后自注册到服务注册中心，并保持定期心跳；</li><li>用户通过发布系统调用服务注册中心调拨流量，实现蓝绿，金丝雀或灰度发布等机制；</li><li>网关和内部微服务客户端定期同步服务注册中心上的服务路由表，将流量按负载均衡策略分发到新的服务实例上。</li></ol><p>另外，持续交付流水线（CD Pipeline）也是微服务发布重要环节，这块主要和研发流程相关，一般需要企业定制，下面是一个可供参考的流水线模型，在镜像治理中心上封装一些轻量级的治理流程，例如只有通过测试环境测试的镜像才能升级发布到UAT环境，只有通过UAT环境测试的镜像才能升级发布到生产环境，通过在流水线上设置一些质量门，保障应用高质量交付到生产。</p><p><img src="/images/2018052902/cd.png" alt="cd pipeline"></p><h3 id="十、写在最后"><a href="#十、写在最后" class="headerlink" title="十、写在最后"></a>十、写在最后</h3><p>注意，本文限于篇幅，对测试和CI等环节没有涉及，但它们同样是构建微服务架构的重要环节，也有众多成熟的开源成熟产品可选。</p><p>技术选型虽然重要，但还只是微服务建设的一小部分工作，选型后的产品要在企业内部真正落地，形成完整的微服务技术栈体系，则后续还有大量集成、定制、治理、运维和推广等工作。</p><p>本文仅限个人经验视角，选型思路仅供参考借鉴。每个企业的具体上下文（业务场景，团队组织，技术架构等）各不相同，每个架构师的背景经验也各不相同，大家要结合实际自己做出选型，没有最好的技术栈，只有相对较合适的技术栈。另外，好的技术选型是相互借鉴甚至PK出来的，欢迎大家讨论，给出自己的微服务2.0技术栈选型意见。</p><h3 id="十一、附录"><a href="#十一、附录" class="headerlink" title="十一、附录"></a>十一、附录</h3><ol><li><a href="https://github.com/spring-projects/spring-boot" target="_blank" rel="noopener">Spring Boot</a></li><li><a href="https://github.com/alibaba/dubbo" target="_blank" rel="noopener">Alibaba Dubbo</a></li><li><a href="https://github.com/grpc/grpc" target="_blank" rel="noopener">Google gRPC</a></li><li><a href="https://github.com/Netflix/eureka" target="_blank" rel="noopener">NetflixOSS Eureka</a></li><li><a href="https://github.com/hashicorp/consul" target="_blank" rel="noopener">Hashicorp Consul</a></li><li><a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">NetflixOSS Zuul</a></li><li><a href="https://github.com/Kong/kong" target="_blank" rel="noopener">Kong</a></li><li><a href="https://github.com/spring-cloud/spring-cloud-config" target="_blank" rel="noopener">Spring Cloud Config</a></li><li><a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">CTrip Apollo</a></li><li><a href="https://github.com/elastic/elasticsearch" target="_blank" rel="noopener">ElasticSearch</a></li><li><a href="https://github.com/Yelp/elastalert" target="_blank" rel="noopener">Yelp Elastalert</a></li><li><a href="https://github.com/dianping/cat" target="_blank" rel="noopener">Dianping CAT</a></li><li><a href="https://github.com/openzipkin/zipkin" target="_blank" rel="noopener">Zipkin</a></li><li><a href="https://github.com/naver/pinpoint" target="_blank" rel="noopener">Naver Pinpoint</a></li><li><a href="https://github.com/OpenTSDB/opentsdb" target="_blank" rel="noopener">OpenTSDB</a></li><li><a href="https://github.com/kairosdb/kairosdb" target="_blank" rel="noopener">KairosDB</a></li><li><a href="https://github.com/salesforce/Argus" target="_blank" rel="noopener">Argus</a></li><li><a href="https://github.com/influxdata/influxdb" target="_blank" rel="noopener">InfluxDB</a></li><li><a href="https://github.com/prometheus/prometheus" target="_blank" rel="noopener">Prometheus</a></li><li><a href="https://github.com/grafana/grafana" target="_blank" rel="noopener">Grafana</a></li><li><a href="https://github.com/sensu/sensu" target="_blank" rel="noopener">Sensu</a></li><li><a href="https://github.com/etsy/411" target="_blank" rel="noopener">Esty 411</a></li><li><a href="https://github.com/zalando/zmon" target="_blank" rel="noopener">Zalando ZMon</a></li><li><a href="https://github.com/Netflix/Hystrix" target="_blank" rel="noopener">NetflixOSS Hystrix</a></li><li><a href="https://github.com/nginx/nginx" target="_blank" rel="noopener">Nginx</a></li><li><a href="https://github.com/apache/kafka" target="_blank" rel="noopener">Apache Kafka</a></li><li><a href="https://github.com/allegro/hermes" target="_blank" rel="noopener">Allegro Hermes</a></li><li><a href="https://github.com/apache/rocketmq" target="_blank" rel="noopener">Apache Rocketmq</a></li><li><a href="https://github.com/rabbitmq/rabbitmq-server" target="_blank" rel="noopener">Rabbitmq</a></li><li><a href="https://github.com/sohutv/cachecloud" target="_blank" rel="noopener">Sohutv CacheCloud</a></li><li><a href="https://github.com/twitter/twemproxy" target="_blank" rel="noopener">Twitter twemproxy</a></li><li><a href="https://github.com/CodisLabs/codis" target="_blank" rel="noopener">CodisLab codis</a></li><li><a href="https://github.com/shardingjdbc/sharding-jdbc" target="_blank" rel="noopener">Dangdang Sharding-jdbc</a></li><li><a href="https://github.com/MyCATApache/Mycat-Server" target="_blank" rel="noopener">MyCAT</a></li><li><a href="https://github.com/xuxueli/xxl-job" target="_blank" rel="noopener">Xxl-job</a></li><li><a href="https://github.com/elasticjob/elastic-job-lite" target="_blank" rel="noopener">Dangdang elastic-job</a></li><li><a href="https://github.com/apereo/cas" target="_blank" rel="noopener">Apereo CAS</a></li><li><a href="https://github.com/keycloak/keycloak" target="_blank" rel="noopener">JBoss keycloak</a></li><li><a href="https://github.com/spring-cloud/spring-cloud-security" target="_blank" rel="noopener">Spring cloud security</a></li><li><a href="https://github.com/mitreid-connect/OpenID-Connect-Java-Spring-Server" target="_blank" rel="noopener">OpenID-Connect-Java-Spring-Server</a></li><li><a href="https://github.com/kubernetes/kubernetes" target="_blank" rel="noopener">Google Kubernetes</a></li><li><a href="https://github.com/apache/mesos" target="_blank" rel="noopener">Apache Mesos</a></li><li><a href="https://github.com/vmware/harbor" target="_blank" rel="noopener">Vmware Harbor</a></li><li><a href="https://github.com/spinnaker/spinnaker" target="_blank" rel="noopener">Netflix Spinnaker</a></li><li><a href="https://wso2.com/whitepapers/microservices-in-practice-key-architectural-concepts-of-an-msa/" target="_blank" rel="noopener">Microservices in Practice – Key Architecture Concepts of an MSA</a></li><li><a href="http://servicecomb.incubator.apache.org/assets/slides/20170619/MSAPrinciple&amp;EcoSystem.pdf" target="_blank" rel="noopener">微服务的设计与生态系统</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;2014年可以认为是微服务1.0的元年，当年有几个标志性事件，一是Martin Fowler在其博客上发表了“Microservices”一文，正式提出微服务架构风格；二是Netflix微服务架构经过多年大规模生产验证，最终抽象落地形成一整套开源的微服务基础组件，统称NetflixOSS，Netflix的成功经验开始被业界认可并推崇；三是Pivotal将NetflixOSS开源微服务组件集成到其Spring体系，推出Spring Cloud微服务开发技术栈。&lt;/p&gt;
&lt;p&gt;一晃三年过去，微服务技术生态又发生了巨大变化，容器，PaaS，Cloud Native，gRPC，ServiceMesh，Serverless等新技术新理念你方唱罢我登场，不知不觉我们又来到了微服务2.0时代。基于近年在微服务基础架构方面的实战经验和平时的学习积累，我想总结并提出一些构建微服务2.0技术栈的选型思路，供各位在一线实战的架构师、工程师参考借鉴。对于一些暂时还没有成熟开源产品的微服务支撑模块，我也会给出一些定制自研的设计思路。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务架构" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="技术选型" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>架构之道~四种核心架构思维</title>
    <link href="http://yoursite.com/2018/05/29/2018052901/"/>
    <id>http://yoursite.com/2018/05/29/2018052901/</id>
    <published>2018-05-29T02:49:22.000Z</published>
    <updated>2018-06-15T11:25:56.583Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>架构的本质是管理复杂性，<strong>抽象、分层、分治和演化思维</strong>是我们工程师/架构师应对和管理复杂性的四种最基本武器。</p><p>最近团队来了一些新人，有些有一定工作经验，是以高级工程师/架构师身份进来的，但我发现他们大部分人思维偏应用和细节，抽象能力弱。所以作为团队技术培训的一部分，我整理了这篇文章，希望对他们树立正确的架构设计思维有帮助。我认为，对思维习惯和思考能力的培养，其重要性远远大于对实际技术工具的掌握。</p><a id="more"></a><p>由于文章内容较长，所以我把它分成两篇小文章，在第一篇《优秀架构师必须掌握的架构思维》中，我会先介绍抽象、分层、分治和演化这四种应对复杂性的基本思维。在第二篇《四个架构设计案例及其思维方式》中，我会通过四个案例，讲解如何综合运用这些思维，分别对小型系统，中型系统，基础架构，甚至是组织技术体系进行架构和设计。</p><h3 id="一、抽象思维"><a href="#一、抽象思维" class="headerlink" title="一、抽象思维"></a>一、抽象思维</h3><p>如果要问软件研发/系统架构中最重要的能力是什么，我会毫不犹豫回答是<strong>抽象</strong>能力。抽象(abstraction)这个词大家经常听到，但是真正理解和能讲清楚什么是抽象的人少之又少。抽象其实是这样定义的：</p><blockquote><p>对某种事物进行简化表示或描述的过程，抽象让我们关注要素，隐藏额外细节。</p></blockquote><p>举一个例子，见下图：</p><p><img src="/images/2018052901/door.jpg" alt="door"></p><p>你看到什么？你看到的是一扇门，对不对？你看到的不是木头，也不是碳原子，这个门就是抽象，而木头或者碳原子是细节。另外你可以看到门上有个门把手，你看到的不是铁，也不是铁原子，门把手就是抽象，铁和铁原子是细节。</p><p>在系统架构和设计中，抽象帮助我们从大处着眼（get our mind about big picture），隐藏细节（temporarily hide details）。抽象能力的强弱，直接决定我们所能解决问题的复杂性和规模大小。</p><p>下图是我们小时候玩的积木，我发现小时候喜欢玩搭积木的，并且搭得快和好的小朋友，一般抽象能力都比较强。</p><p><img src="/images/2018052901/building_blocks.png" alt="building blocks"></p><p>上图右边的积木城堡就是抽象，这个城堡如果你细看的话，它其实还是由若干个子模块组成，这些模块是子抽象单元，左边的各种形状的积木是细节。搭积木的时候，小朋友脑袋里头先有一个城堡的大图（抽象），然后他/她大脑里头会有一个初步的子模块分解（潜意识中完成），然用利用积木搭建每一个子模块，最终拼装出最后的城堡。这里头有一个自顶向下的分治设计，然后自底向上的组合过程，这个分治思维非常重要，我们后面会讲。</p><p>我认为软件系统架构设计和小朋友搭积木无本质差异，只是解决的问题域和规模不同罢了。架构师先要在大脑中形成抽象概念，然后是子模块分解，然后是依次实现子模块，最后将子模块拼装组合起来，形成最后系统。所以我常说编程和架构设计就是搭积木，优秀的架构师受职业习惯影响，眼睛里看到的世界都是模块化拼装组合式的。</p><p>抽象能力不仅对软件系统架构设计重要，对建筑，商业，管理等人类其它领域活动同样非常重要。其实可以这样认为，我们生存的世界都是在抽象的基础上构建起来的，离开抽象人类将寸步难行。</p><p>这里顺便提一下抽象层次跳跃问题，这个在开发中是蛮普遍的。有经验的程序员写代码会保持抽象层次的一致性，代码读起来像讲故事，比较清晰易于理解；而没有经验的程序员会有明显的抽象层次跳跃问题，代码读起来就比较累，这个是抽象能力不足造成。举个例子，</p><p><img src="/images/2018052901/online_store.png" alt="online store"></p><p>一个电商网站在处理订单时，一般会走这样一个流程：</p><ol><li>更新库存(InventoryUpdate)</li><li>打折计算(Discounting)</li><li>支付卡校验(PaycardVerification)</li><li>支付(Pay)</li><li>送货(Shipping)</li></ol><p>上述流程中的抽象是在同一个层次上的，比较清晰易于理解，但是没有经验的程序员在实现这个流程的时候，代码层次会跳，比方说主流程到支付卡校验一块，他的代码会突然跳出一行某银行API远程调用，这个就是抽象跳跃，银行API调用是细节，应该封装在PaycardVerification这个抽象里头。</p><h3 id="二、分层思维"><a href="#二、分层思维" class="headerlink" title="二、分层思维"></a>二、分层思维</h3><p>除了抽象，<strong>分层</strong>也是我们应对和管理复杂性的基本思维武器，如下图，为了构建一套复杂系统，我们把整个系统划分成若干个层次，每一层专注解决某个领域的问题，并向上提供服务。有些层次是纵向的，它贯穿所有其它层次，称为共享层。分层也可以认为是抽象的一种方式，将系统抽象分解成若干层次化的模块。</p><p><img src="/images/2018052901/layered_arch.png" alt="layered architecture"></p><p>分层架构的案例很多，一个中小型的Spring Web应用程序，我们一般会设计成三层架构：</p><p><img src="/images/2018052901/layered_webapp.png" alt="layered web app"></p><p>操作系统是经典的分层架构，如下图：</p><p><img src="/images/2018052901/layered_os.png" alt="layered os"></p><p>TCP/IP协议栈也是经典的分层架构，如下图：</p><p><img src="/images/2018052901/layered_tcpip.gif" alt="layered tcp/ip"></p><p>如果你关注人类文明演化史，你会发现今天的人类世界也是以分层方式一层层搭建和演化出来的。今天的互联网系统可以认为是现代文明的一个层次，其上是基于互联网的现代商业，其下是现代电子工业基础设施，诸如此类。</p><h3 id="三、分治思维"><a href="#三、分治思维" class="headerlink" title="三、分治思维"></a>三、分治思维</h3><p><strong>分而治之</strong>(divide and combine或者split and merge)也是应对和管理复杂复杂性的一般性方法，下图展示一个分治的思维流程：</p><p><img src="/images/2018052901/divide_and_combile.png" alt="divide and combile"></p><p>对于一个无法一次解决的大问题，我们会先把大问题分解成若干个子问题，如果子问题还无法直接解决，则继续分解成子子问题，直到可以直接解决的程度，这个是分解(divide)的过程；然后将子子问题的解组合拼装成子问题的解，再将子问题的解组合拼装成原问题的解，这个是组合(combine)的过程。</p><p>面试时为了考察候选人的分治思维，我经常会面一个分治题：给你一台8G内存/500G磁盘空间的普通电脑，如何对一个100G的大文件进行排序？假定文件中都是字符串记录，一行约100个字符。</p><p>这是一个典型的分治问题，100G的大文件肯定无法一次加载到内存直接排序，所以需要先切分成若干小问题来解决。那么8G内存的计算机一次大概能排多大的数据量，可以在有限的时间内排完呢？也就是100G的大文件要怎么切法，切成多少份比较合适？这个是考察候选人的时间空间复杂度估算能力，需要一定的计算机组织和算法功底，也需要一定实战经验和sense。实际上8G内存的话，操作系统要用掉一部分，如果用Java开发排序程序，大致JVM可用2~4G内存，基于一般的经验值，一次排1G左右的数据应该没有问题（我实际在计算机上干过1G数据的排序，是OK的）。所以100G的文件需要先切分成100份，每份1G，这样每个子文件可以直接加载到内存进行排序。对于1G数据量的字符串排序，采用Java里头提供的快速排序算法是比较合适的。</p><p>好，经过有限时间的排序（取决于计算机性能，快的一天内能排完），假定100个1G的文件都已经排好了，相当于现在硬盘上有100个已经排好序的文件，但是我们最终需要的是一个排好序的文件，下面该怎么做？这个时候我们需要把已经解决的子问题组合起来，合并成我们需要的最终结果文件。这个时候该采用什么算法呢？这里考察候选人对外排序和归并排序算法的掌握程度，我们可以将100个排好序的文件进行两两归并排序，这样不断重复，我们就会得到50个排好序的文件，每个大小是2G。然后再两两归并，不断重复，直到最后两个文件归并成目标文件，这个文件就是100G并且是排好序的。因为是外排序+归并排序，每次只需要读取当前索引指向的文件记录到内存，进行比较，小的那个输出到目标文件，内存占用极少。另外，上面的算法是两路归并，也可以采用多路归并，甚至是采用堆排序进行优化，但是总体分治思路没有变化。</p><p>总体上这是一个非常好的面试题，除了考察候选人的分治思维之外，还考察对各种排序算法（快排，外排序，归并排序，堆排序）的理解，计算的时间空间复杂度估算，计算机的内外存特性和组织，文件操作等等。实际上能完全回答清楚这个问题的候选人极少，如果有幸被我面到一个，我会如获至宝，因为这个人有成长为优秀架构师的潜质。</p><p>另外，递归也是一种特殊的分治技术，掌握递归技术的开发人员，相当于掌握了一种强大的编程武器，可以解决一些一般开发人员无法解决的问题。比方说最近我的团队在研发一款新的服务框架，其中包括契约解析器(parser)，代码生产器(code generator)，序列化器(serializer)等组件，里头大量需要用到递归的思维和技术，没有这个思维的开发人员就干不了这个事情。所以我在面试候选人的时候，一般都会出递归相关的编程题，考察候选人的递归思维。</p><p>大自然中递归结构比比皆是，如下图，大家有兴趣不妨思考，大自然通过递归给我们人类何种启示？</p><p><img src="/images/2018052901/leaf_recursion.png" alt="leaf recursion"></p><p><img src="/images/2018052901/recursion_in_nature.jpg" alt="recursion in nature"><br>这个是我平时经常看着发呆和浮想联翩的一个图</p><h3 id="四、演化思维"><a href="#四、演化思维" class="headerlink" title="四、演化思维"></a>四、演化思维</h3><p>社区里头经常有人在讨论：架构是设计出来的？还是演化出来的？我个人基于十多年的经验认为，架构既是设计出来的，同时也是演化出来的，对于互联网系统，基本上可以说是三分设计，七分演化，而且是在设计中演化，在演化中设计，一个不断迭代的过程。</p><p>在互联网软件系统的整个生命周期过程中，前期的设计和开发大致只占三分，在后面的七分时间里，架构师需要根据用户的反馈对架构进行不断的调整。我认为架构师除了要利用自身的架构设计能力，同时也要学会借助用户反馈和进化的力量，推动架构的持续演进，这个就是演化式架构思维。</p><p>当然一开始的架构设计非常重要，架构定系统基本就成型了，不容马虎。同时，优秀的架构师深知，能够不断应对环境变化的系统，才是有生命力的系统，架构的好坏，很大部分取决于它应对变化的灵活性。所以具有演化式思维的架构师，能够在一开始设计时就考虑到后续架构的演化特性，并且将灵活应对变化的能力作为架构设计的主要考量。</p><p>当前，社区正在兴起一种新的架构方法学~演化式架构，微服务架构就是一种典型的演化式架构，它能够快速响应市场用户需求的变化，而单块架构就缺乏这种灵活性。马丁.福乐曾经在其博客上给出过一张微服务架构的演化路线图[附录7.2]，可以用来解释设计式思维和演化式思维的差异，如下图所示：</p><p><img src="/images/2018052901/msa_evoluation.png" alt="msa evoluation"></p><p>上面的路线是一开始就直奔微服务架构，其实背后体现的是设计式架构的思维，认为架构师可以完全设计整个系统和它的演化方向。马丁认为这种做法风险非常高，一个是成本高昂，另外一个是刚开始架构师对业务域理解不深，无法清晰划分领域边界，开发出来的系统很可能无法满足用户需求。</p><p>下面的路线是从单块架构开始，随着架构师对业务域理解的不断深入，也随着业务和团队规模的不断扩大，渐进式地把单块架构拆分成微服务架构的思路，这就是演化式架构的思维。如果你观察现实世界中一些互联网公司（例如eBay，阿里，Netflix等等）的系统架构，大部分走得都是演化式架构的路线。</p><p>下图是建筑的演化史，在每个阶段，你可以看到设计的影子，但如果时间线拉得足够长，演化的特性就出来了。</p><p><img src="/images/2018052901/the_evoluation_of_architecture.png" alt="the evoluation of architecture"></p><h3 id="五、如何培养架构设计思维"><a href="#五、如何培养架构设计思维" class="headerlink" title="五、如何培养架构设计思维"></a>五、如何培养架构设计思维</h3><p>良好的架构设计思维的培养，离不开工作中大量高质量项目的实战锻炼，然后是平时的学习、思考和提炼总结。</p><p>另外，基本的架构设计思维，其实在我们大学计算机课程（比如数据结构和算法）中可以找到影子，只不过当时以学习为主，问题域比较小和理想化。所以大学教育其实非常重要，基本的架构设计思维在那个时候就已经埋下种子，后面工程实践中进一步消化和应用，随着经验的积累，我们能够解决的问题域复杂性和规模逐渐变大，但基本的武器还是抽象、分层和分治等思维。</p><p>我认为一个架构师的成长高度和他大学期间的思维习惯的养成关系密切。我所知道世界一流的互联网公司，例如谷歌等，招聘工程师新人时，对数据结构和算法的要求可以用苛刻来形容，这个可以理解，谷歌级别公司要解决的问题都是超级复杂的，基本思维功底薄弱根本无法应对。</p><p>对于工作经验&lt;5年的工程师新手，如果你大学时代是属于荒废型的，建议工作之余把相关课程再好好自学一把。个人推荐参考美国Berkeley大学的数据结构课程CS61B[附录7.1]进行学习，对建立抽象编程思维非常有帮助，我本人在研究生阶段自学过这门课程，现在回想起来确实受益匪浅，注意该课程中的所有Lab/Homework/Project都要实际动手做一遍，才有好的效果。</p><p><img src="/images/2018052901/cs61b2006.jpg" alt="cs61b 2006"></p><p>我当年自学的是CS61B 2006秋季版的课程，上图是课程Logo</p><p>另外，推荐《代码大全》[附录7.3]一书给大家，这本是书是所有软工行业从业人员的必读书，其中有对软件本质复杂性和抽象精彩描述，我职业早年也经常读此书，同样受益匪浅。</p><p><img src="/images/2018052901/code_complete.jpg" alt="code complete"></p><p>对于演化设计思维，当前的大学教育其实培养很少，相反，当前大学教育大都采用脱离现实场景的简化理想模型，有些还是固定答案的应试教学，这种方式会造成学生思维确定化，不利于培养演化式设计思维。我个人的体会，演化式设计思维更多在实际工作中通过实战锻炼和培养。</p><h3 id="六、结论"><a href="#六、结论" class="headerlink" title="六、结论"></a>六、结论</h3><ol><li>架构的本质是管理复杂性，抽象、分层、分治和演化思维是架构师征服复杂性的四种根本性武器</li><li>掌握了抽象、分层、分治和演化这四种基本的武器，你可以设计小到一个类，一个模块，一个子系统，或者一个中型的系统，也可以大到一个公司的基础平台架构，微服务架构，技术体系架构，甚至是组织架构，业务架构等等。</li><li>架构设计不是静态的，而是动态演化的。只有能够不断应对环境变化的系统，才是有生命力的系统。所以即使你掌握了抽象、分层和分治这三种基本思维，仍然需要演化式思维，在设计的同时，借助反馈和进化的力量推动架构的持续演进。</li><li>架构师在关注技术，开发应用的同时，需要定期梳理自己的架构设计思维，积累时间长了，你看待世界事物的方式会发生根本性变化，你会发现我们生活其中的世界，其实也是在抽象、分层、分治和演化的基础上构建起来的。另外架构设计思维的形成，会对你的系统架构设计能力产生重大影响。可以说对抽象、分层、分治和演化掌握的深度和灵活应用的水平，直接决定架构师所能解决问题域的复杂性和规模大小，是区分普通应用型架构师和平台型/系统型架构师的一个分水岭。</li></ol><h3 id="七、附录"><a href="#七、附录" class="headerlink" title="七、附录"></a>七、附录</h3><ol><li><p><a href="http://datastructur.es/sp17/" target="_blank" rel="noopener">Berkeley CS61B</a></p></li><li><p><a href="https://www.martinfowler.com/bliki/MonolithFirst.html" target="_blank" rel="noopener">单块优先</a></p></li><li><p><a href="https://www.amazon.cn/dp/B0061XKRXA" target="_blank" rel="noopener">代码大全</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;架构的本质是管理复杂性，&lt;strong&gt;抽象、分层、分治和演化思维&lt;/strong&gt;是我们工程师/架构师应对和管理复杂性的四种最基本武器。&lt;/p&gt;
&lt;p&gt;最近团队来了一些新人，有些有一定工作经验，是以高级工程师/架构师身份进来的，但我发现他们大部分人思维偏应用和细节，抽象能力弱。所以作为团队技术培训的一部分，我整理了这篇文章，希望对他们树立正确的架构设计思维有帮助。我认为，对思维习惯和思考能力的培养，其重要性远远大于对实际技术工具的掌握。&lt;/p&gt;
    
    </summary>
    
      <category term="系统架构" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构思维" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84%E6%80%9D%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>架构之道~现代发布模式</title>
    <link href="http://yoursite.com/2018/05/28/20180528/"/>
    <id>http://yoursite.com/2018/05/28/20180528/</id>
    <published>2018-05-28T08:33:31.000Z</published>
    <updated>2018-06-15T07:37:55.273Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>根据2017年的DevOps发展报告，高效能组织和低效能组织在软件交付的效率上有数量级上的差异。技术组织的软件交付能力是一种综合能力，涉及众多环节，其中发布是尤为重要的环节。</p><p>作为技术人员，大家可能听说过“滚动发布”和“蓝绿发布”等术语，但是很多人并不清楚这些术语背后的原理。本文试图总结当前主流的发布策略，每个的优劣，适用性，让开发人员特别是架构师对现代发布技术有一个更为清晰全面的认识，让大家能够根据自己的企业上下文，对发布策略做出正确的选型和实践。</p><a id="more"></a><h3 id="一、单服务器组发布"><a href="#一、单服务器组发布" class="headerlink" title="一、单服务器组发布"></a>一、单服务器组发布</h3><p>先解释下单服务器组的概念，早先我们机器资源比较紧张，不像现在云计算和虚拟化（包括容器技术）这么发达，所以应用机器基本是预先静态分配好的（一般由运维负责分配），原来应用A住在这n台机器上，那么下次升级发布的应用A也住在这n台机器上，所以称为单服务器组发布方式。</p><h4 id="1-1-蛮力发布"><a href="#1-1-蛮力发布" class="headerlink" title="1.1 蛮力发布"></a>1.1 蛮力发布</h4><p>如下图所示，这种发布方式比较简单粗暴，有点像我们传统的软件升级方式，主要靠手工完成，先将老版本V1全部下掉，再将新版本发到机器上去。这种方式会引入服务中断（停机），在开发测试环境是可行的，但对于生产环境发布，其会直接影响用户的使用体验，这种方式一般是不建议的。</p><p><img src="/images/20180528/reckless_1.png" alt="reckless before"></p><center style="margin: -20px 0 20px">发布前</center><p><img src="/images/20180528/reckless_2.png" alt="reckless after"></p><center style="margin: -20px 0 20px">发布后</center><h5 id="优势和适用场合"><a href="#优势和适用场合" class="headerlink" title="优势和适用场合"></a>优势和适用场合</h5><p><strong>优势：</strong></p><ul><li>简单成本低</li></ul><p><strong>不足：</strong></p><ul><li>服务中断用户受影响，出了问题回退也慢</li></ul><p><strong>适用场合：</strong></p><ul><li>开发测试环境</li><li>非关键应用（用户影响面小）</li><li>初创公司什么都缺，找夜深人静用户访问量小的时间干</li></ul><h5 id="流量模式"><a href="#流量模式" class="headerlink" title="流量模式"></a>流量模式</h5><p><img src="/images/20180528/reckless_traffic.png" alt="reckless traffic model"></p><p>蛮力发布会引入服务中断时间，图片来自[附录6.1]</p><h4 id="1-2-金丝雀发布（单服务器组）"><a href="#1-2-金丝雀发布（单服务器组）" class="headerlink" title="1.2 金丝雀发布（单服务器组）"></a>1.2 金丝雀发布（单服务器组）</h4><p>在蛮力发布基础上的一种简单改进发布方式，目前仍然是不少成长型技术组织的主流发布方式。单服务器组下的金丝雀发布的简化步骤如下图所示：</p><p><img src="/images/20180528/canary_1group_1.png" alt="canary one group before"></p><center style="margin: -20px 0 20px">发布前</center><p><img src="/images/20180528/canary_1group_2.png" alt="canary one group first"></p><center style="margin: -20px 0 20px">先发一台金丝雀</center><p><img src="/images/20180528/canary_1group_3.png" alt="canary one group after"></p><center style="margin: -20px 0 20px">全部发完</center><h5 id="实践要点"><a href="#实践要点" class="headerlink" title="实践要点"></a>实践要点</h5><ol><li>金丝雀发布一般先发1台，或者一个小比例，例如2%的服务器，主要做流量验证用，也称为金丝雀(Canary)测试（国内常称灰度测试）。以前旷工开矿下矿洞前，先会放一只金丝雀进去探是否有有毒气体，看金丝雀能否活下来，金丝雀发布由此得名。简单的金丝雀测试一般通过手工测试验证，复杂的金丝雀测试需要比较完善的监控基础设施配合，通过监控指标反馈，观察金丝雀的健康状况，作为后续发布或回退的依据。</li><li>如果金丝测试通过，则把剩余的V1版本全部升级为V2版本。如果金丝雀测试失败，则直接回退金丝雀，发布失败。</li></ol><p><img src="/images/20180528/canary.png" alt="canary"></p><center style="margin: -20px 0 20px">金丝雀</center><h5 id="优势和适用场合-1"><a href="#优势和适用场合-1" class="headerlink" title="优势和适用场合"></a>优势和适用场合</h5><p><strong>优势：</strong></p><ul><li>用户体验影响小，金丝雀发布过程出现问题只影响少量用户</li></ul><p><strong>不足：</strong></p><ul><li>发布自动化程度不够，发布期间可引发服务中断</li></ul><p><strong>适用场合：</strong></p><ul><li>对新版本功能或性能缺乏足够信心</li><li>用户体验要求较高的网站业务场景</li><li>缺乏足够的自动化发布工具研发能力</li></ul><h5 id="流量模式-1"><a href="#流量模式-1" class="headerlink" title="流量模式"></a>流量模式</h5><p><img src="/images/20180528/canary_1group_traffic.png" alt="canary one group traffic"></p><p>少量金丝雀先接受流量，再全量发布，图片来自[附录6.1]</p><h4 id="1-3-滚动式发布（单服务器组）"><a href="#1-3-滚动式发布（单服务器组）" class="headerlink" title="1.3 滚动式发布（单服务器组）"></a>1.3 滚动式发布（单服务器组）</h4><p>在金丝雀发布基础上的进一步优化改进，是一种自动化程度较高的发布方式，用户体验比较平滑，是目前成熟型技术组织所采用的主流发布方式。单服务器组下的滚动发布的简化步骤如下图所示：</p><p><img src="/images/20180528/rolling_update_1group_1.png" alt="rolling update one group before"></p><center style="margin: -20px 0 20px">发布前</center><p><img src="/images/20180528/rolling_update_1group_2.png" alt="rolling update one group first"></p><center style="margin: -20px 0 20px">发布中，先发一台金丝雀</center><p><img src="/images/20180528/rolling_update_1group_3.png" alt="rolling update one group middle"></p><center style="margin: -20px 0 20px">发布中，再发若干台</center><p><img src="/images/20180528/rolling_update_1group_4.png" alt="rolling update one group after"></p><center style="margin: -20px 0 20px">直到全部发完</center><h5 id="实践要点-1"><a href="#实践要点-1" class="headerlink" title="实践要点"></a>实践要点</h5><ol><li>滚动式发布一般先发1台，或者一个小比例，如2%服务器，主要做流量验证用，类似金丝雀(Canary)测试。</li><li>滚动式发布需要比较复杂的发布工具和智能LB，支持平滑的版本替换和流量拉入拉出。</li><li>每次发布时，先将老版本V1流量从LB上摘除，然后清除老版本，发新版本V2，再将LB流量接入新版本。这样可以尽量保证用户体验不受影响。</li><li>一次滚动式发布一般由若干个发布批次组成，每批的数量一般是可以配置的（可以通过发布模板定义）。例如第一批1台（金丝雀），第二批10%，第三批50%，第四批100%。每个批次之间留观察间隔，通过手工验证或监控反馈确保没有问题再发下一批次，所以总体上滚动式发布过程是比较缓慢的(其中金丝雀的时间一般会比后续批次更长，比如金丝雀10分钟，后续间隔2分钟)。</li><li>回退是发布的逆过程，将新版本流量从LB上摘除，清除新版本，发老版本，再将LB流量接入老版本。和发布过程一样，回退过程一般也比较慢的。</li><li>滚动式发布国外术语通常叫Rolling Update Deployment。</li></ol><h5 id="优势和适用场合-2"><a href="#优势和适用场合-2" class="headerlink" title="优势和适用场合"></a>优势和适用场合</h5><p><strong>优势：</strong></p><ul><li>用户体验影响小，体验较平滑</li></ul><p><strong>不足：</strong></p><ul><li>发布和回退时间比较缓慢</li><li>发布工具比较复杂，LB需要平滑的流量摘除和拉入能力</li></ul><p><strong>适用场合：</strong></p><ul><li>用户体验不能中断的网站业务场景</li><li>有一定的复杂发布工具研发能力；</li></ul><h5 id="流量模式-2"><a href="#流量模式-2" class="headerlink" title="流量模式"></a>流量模式</h5><p><img src="/images/20180528/rolling_update_traffic.png" alt="rolling udpate one group traffic"></p><p>滚动式发布，流量平滑过渡，图片来自[附录6.1]</p><h3 id="二、双服务器组发布"><a href="#二、双服务器组发布" class="headerlink" title="二、双服务器组发布"></a>二、双服务器组发布</h3><p>随着云计算和虚拟化技术的成熟，特别是容器等轻量级虚拟化技术的引入，计算资源受限和申请缓慢问题已经逐步解决，可以做到弹性按需分配。为一次发布分配两组服务器，一组运行现有的V1老版本，一组运行待上线的V2新版本，再通过LB切换流量方式完成发布，这就是所谓的双服务器组发布方式。</p><h4 id="2-1-蓝绿发布（双服务器组）"><a href="#2-1-蓝绿发布（双服务器组）" class="headerlink" title="2.1 蓝绿发布（双服务器组）"></a>2.1 蓝绿发布（双服务器组）</h4><p>蓝绿发布仅适用于双服务器组发布，可以认为是对蛮力发布的一种简单优化发布方式。简化过程如下图所示：</p><p><img src="/images/20180528/blue_green_2groups_before.png" alt="blue green two groups before"></p><center style="margin: -20px 0 20px">发布前</center><p><img src="/images/20180528/blue_green_2groups_after.png" alt="blue green two groups after"></p><center style="margin: -20px 0 20px">发布后</center><h5 id="实践要点-2"><a href="#实践要点-2" class="headerlink" title="实践要点"></a>实践要点</h5><ol><li>V1版本称为蓝组，V2版本称为绿组，发布时通过LB一次性将流量从蓝组直接切换到绿组，不经过金丝雀和滚动发布，蓝绿发布由此得名；</li><li>出现问题回退也很直接，通过LB直接将流量切回蓝组。</li><li>发布初步成功后，蓝组机器一般不直接回收，而是留一个待观察期，视具体情况观察期的时间可长可短，观察期过后确认发布无问题，则可以回收蓝组机器。</li></ol><h5 id="优势和适用场合-3"><a href="#优势和适用场合-3" class="headerlink" title="优势和适用场合"></a>优势和适用场合</h5><p><strong>优势：</strong></p><ul><li>升级切换和回退速度非常快</li></ul><p><strong>不足：</strong></p><ul><li>切换是全量的，如果V2版本有问题，则对用户体验有直接影响；</li><li>需要两倍机器资源；</li></ul><p><strong>适用场合：</strong></p><ul><li>对用户体验有一定容忍度的场景</li><li>机器资源有富余或者可以按需分配（AWS云，或自建容器云）</li><li>暂不具备复杂滚动发布工具研发能力；</li></ul><h5 id="流量模式-3"><a href="#流量模式-3" class="headerlink" title="流量模式"></a>流量模式</h5><p><img src="/images/20180528/blue_green_2groups_traffic.png" alt="blue green two groups traffic"></p><p>蓝绿发布一次完成流程切换，图片来自[附录6.1]</p><h4 id="2-2-金丝雀发布（双服务器组）"><a href="#2-2-金丝雀发布（双服务器组）" class="headerlink" title="2.2 金丝雀发布（双服务器组）"></a>2.2 金丝雀发布（双服务器组）</h4><p>对蓝绿部署的一种简单优化，发布时先从绿组拉入1台金丝雀，待金丝雀验证通过再发全量。对比蓝绿发布，该发布方式的优势是有一个生产流量的金丝雀验证过程，可以减轻V2可能有问题的风险和影响面。简化发布过程如下图所示：</p><p><img src="/images/20180528/canary_2groups_1.png" alt="canary two groups before"></p><center style="margin: -20px 0 20px">发布前</center><p><img src="/images/20180528/canary_2groups_2.png" alt="canary two groups middle"></p><center style="margin: -20px 0 20px">发布中，先发一台金丝雀</center><p><img src="/images/20180528/canary_2groups_3.png" alt="canary two groups after"></p><center style="margin: -20px 0 20px">全量发布</center><h4 id="2-3-滚动式发布（双服务器组）"><a href="#2-3-滚动式发布（双服务器组）" class="headerlink" title="2.3 滚动式发布（双服务器组）"></a>2.3 滚动式发布（双服务器组）</h4><p>滚动式发布是对上面的蓝绿和金丝雀发布的进一步优化，按批次增量滚动发布，提供更平滑的用户体验。</p><p><img src="/images/20180528/rolling_update_2groups_1.png" alt="rolling update two groups before"></p><center style="margin: -20px 0 20px">发布前</center><p><img src="/images/20180528/rolling_update_2groups_2.png" alt="rolling update two groups first"></p><center style="margin: -20px 0 20px">发布中，先发一台金丝雀</center><p><img src="/images/20180528/rolling_update_2groups_3.png" alt="rolling update two groups middle"></p><center style="margin: -20px 0 20px">发布中，再发若干台</center><p><img src="/images/20180528/rolling_update_2groups_4.png" alt="rolling update two groups after"></p><center style="margin: -20px 0 20px">直到全部发完</center><h4 id="实践要点-3"><a href="#实践要点-3" class="headerlink" title="实践要点"></a>实践要点</h4><ol><li>发布前先申请一批新服务器，数量一般和V1版本相同，将V2版本应用发布到新服务器上。例如如果在AWS云上，则可以直接调用API申请一批新VM，如果用容器云k8s，则可以直接启动一批新容器（使用V2版本容器镜像）。</li><li>一般会先通过LB拉入1台V2版本的机器，这台机器也相当于金丝雀，用于流量验证。</li><li>逐步按批次完成发布，每批只需要通过LB拉入V2版本，再拉出对应数量的V1版本。批次之间留有观察间隔，通过手工或监控反馈确保没有问题再继续发布。</li><li>发布有问题回退很快，直接通过LB将流量切回V1即可。</li><li>完成发布后，一般V1版本要保留观察以备万一，比如留1天，1天后没有问题则回收V1机器资源。</li></ol><h5 id="优势和适用场合-4"><a href="#优势和适用场合-4" class="headerlink" title="优势和适用场合"></a>优势和适用场合</h5><p><strong>优势：</strong></p><ul><li>用户体验影响小；</li><li>升级切换和回退（rollback）速度比单服务器组滚动发布要快，LB切流量即可；</li></ul><p><strong>不足：</strong></p><ul><li>需要两倍机器资源；</li><li>发布工具比较复杂，LB需要流量切换能力</li></ul><p><strong>适用场合：</strong></p><ul><li>用户体验不能中断的网站业务场景</li><li>机器资源有富余或者可以按需分配（AWS云，或自建容器云）</li><li>有一定的发布工具研发能力；</li></ul><h5 id="流量模式-4"><a href="#流量模式-4" class="headerlink" title="流量模式"></a>流量模式</h5><p><img src="/images/20180528/rolling_update_traffic.png" alt="rolling upodate two groups traffic"></p><p>滚动式发布，流量平滑过渡，图片来自[附录6.1]</p><h3 id="三、其它发布方式"><a href="#三、其它发布方式" class="headerlink" title="三、其它发布方式"></a>三、其它发布方式</h3><p>上述都是偏传统的发布方式，能覆盖大部分应用发布场景。针对一些关键新功能的上线发布，或者一些特定的场景，还有一些特殊的发布方式。</p><h4 id="3-1-功能开关发布"><a href="#3-1-功能开关发布" class="headerlink" title="3.1 功能开关发布"></a>3.1 功能开关发布</h4><p>利用代码中的功能开关（Feature Flag/Toggle/Switch）来控制发布逻辑，一般不需要复杂的发布工具和智能LB配合，是一种相对比较低成本和简单的发布方式。这种方式也是支持现代DevOps理念，研发人员可以灵活定制和自助完成的发布方式。功能开关的原理如下图所示：</p><p><img src="/images/20180528/feature_flag_deployment.png" alt="feature flag deployment"></p><p>功能开关发布，图片来自[附录6.2]</p><h5 id="实践要点-4"><a href="#实践要点-4" class="headerlink" title="实践要点"></a>实践要点</h5><ol><li>功能开关发布需要一个配置中心或者开关中心这样的服务支持，例如携程的Apollo配置中心[附录6.3]，或者开源的FF4J[附录6.4]，这些都支持开关发布，业界还有专门的功能开关SaaS服务，例如LaunchDarkly[附录6.5]。通过配置中心，运维或研发人员可以在运行期动态配置功能开关的值。当然，功能开关发布只是配置中心的一种使用场景，配置中心还能支持其它很多动态配置场景。</li><li>功能开关服务一般提供客户端SDK，方便开发人员集成。在运行期，客户端SDK会同步最新的开关值，技术实现有推方式(push)，也有拉方式(pull)，或者推拉结合方式。</li><li>新功能（V2 new feature）和老功能（V1 old feature）住在同一套代码中，新功能隐藏在开关后面，如果开关没有打开，则走老代码逻辑，如果开关打开，则走新代码逻辑。技术实现上可以理解为一个简单的if/else逻辑。</li><li>应用上线后，开关先不打开，然后运维或研发人员通过开关中心打开新功能，经过流量验证新功能没有问题，则发布完成；如果有问题，则随时可以通过开关中心切回老功能逻辑。</li></ol><h5 id="优势和适用场合-5"><a href="#优势和适用场合-5" class="headerlink" title="优势和适用场合"></a>优势和适用场合</h5><p><strong>优势：</strong></p><ul><li>升级切换和回退速度非常快</li><li>相对于复杂的发布工具，实施比较简单，成本相对低廉</li><li>研发能够灵活定制发布逻辑，支持DevOps自助发布</li></ul><p><strong>不足：</strong></p><ul><li>切换是全量的，如果V2版本有问题，则对用户体验有直接影响；</li><li>对代码有侵入，代码逻辑会变复杂，需要定期清理老版本逻辑，维护成本变高</li></ul><p><strong>适用场合：</strong></p><ul><li>对用户体验有一定容忍度的场景</li><li>已有配置中心或开关中心服务</li><li>暂不具备研发复杂发布工具能力；</li></ul><h5 id="流量模式-5"><a href="#流量模式-5" class="headerlink" title="流量模式"></a>流量模式</h5><p><img src="/images/20180528/blue_green_2groups_traffic.png" alt="feature flag traffic"></p><p>通过功能开关一次完成流量切换，图片来自[附录6.1]</p><h4 id="3-2-A-B测试"><a href="#3-2-A-B测试" class="headerlink" title="3.2 A/B测试"></a>3.2 A/B测试</h4><p>A/B测试[附录6.10]原来主要用于产品功能的比对测试，收集用户反馈和对比数据做产品功能设计的决策。实际上，A/B测试也可以作为一种新功能发布技术。下图展示基于LB实现的一种A/B测试发布。</p><p><img src="/images/20180528/ab_testing_deployment.png" alt="a/b testing deployment"></p><h5 id="实践要点-5"><a href="#实践要点-5" class="headerlink" title="实践要点"></a>实践要点</h5><ol><li>上图中，原来PC端和手机端都访问老版本V1服务（也称A组或控制组），当V2新版本（也称B组或实验组）发布以后，为了验证V2的功能正确性，同时也为了避免V2有问题时影响所有用户，先通过LB将手机端的流量切换到V2版本，经过一段时间的A/B比对测试和观察（主要通过用户和监控反馈），确保V2正常，则通过LB将全部流量切换到V2。</li><li>基于LB方式实现A/B测试，LB需要能够通过某种条件做流量路由，例如通过client ip，设备类型，浏览器类型，甚至是定制的http header或查询字符串。</li><li>高级的A/B测试需要专门的平台支撑，wasabi[附录6.6]就是intuit开源的一个支持高级A/B测试的平台，这类平台可以细粒度到针对某类用户做A/B测试，例如针对某个地区的用户，某个年龄段的用户，公司内部用户等等。举了例子，假设一个关键业务的新功能上线，为了降低风险采用A/B测试，可以做到先只让公司内部员工能访问到新功能，待新功能验证过，再全量放开给外部用户使用。</li><li>功能开关和A/B测试有点相似，但功能开关一般是无状态和全量的，无法做到针对某类特定用户进行测试，而A/B测试一般是有状态的，能够跟踪事务和用户级别的状态，可以实现针对某类特定用户进行测试。</li></ol><h5 id="优势和适用场合-6"><a href="#优势和适用场合-6" class="headerlink" title="优势和适用场合"></a>优势和适用场合</h5><p><strong>优势：</strong></p><ul><li>用户体验影响小；</li><li>可以使用生产流量测试；</li><li>可以做到针对某类特定目标用户进行测试；</li></ul><p><strong>不足：</strong></p><ul><li>搭建复杂度相对高，有一定技术门槛</li></ul><p><strong>适用场合：</strong></p><ul><li>核心关键业务，比如涉及资金的</li><li>具备一定的A/B测试平台研发能力</li></ul><h5 id="流量模式-6"><a href="#流量模式-6" class="headerlink" title="流量模式"></a>流量模式</h5><p><img src="/images/20180528/ab_testing_traffic.png" alt="a/b testing traffic"></p><p>针对某类目标用户进行A/B测试，图片来自[附录6.1]</p><h4 id="3-3-影子测试"><a href="#3-3-影子测试" class="headerlink" title="3.3 影子测试"></a>3.3 影子测试</h4><p>对于一些涉及核心业务的遗留系统的升级改造，为了确保万无一失，有一种称为影子测试的大招，采用比较复杂的流量复制、回放和比对技术实现。下面是影子测试的一个样例架构图，</p><p><img src="/images/20180528/shadow_testing.png" alt="shadow testing"></p><h5 id="实践要点-6"><a href="#实践要点-6" class="headerlink" title="实践要点"></a>实践要点</h5><ol><li>目标实现老的legacy服务迁移升级到新的experimental服务。</li><li>测试开始前，需要在测试环境部署一份legacy服务和experimental服务，同时将生产数据库复制两份到测试环境。同时需要将生产请求日志收集起来，一般可以通过kafka队列收集，然后通过类似goreplay[附录6.8]这样的工具，消费kafka里头的请求日志，复制回放，将请求分发到legacy服务和experimental服务，收到响应后进行比对，如果所有响应比对成功，则可以认为legacy服务和experimental服务在功能逻辑上是等价的；如果有响应比对失败，则认为两者在功能逻辑上不等价，需要修复experimental并重新进行影子测试，直到全部比对成功。根据系统复杂度和关键性不同，比对测试时间短的可能需要几周，长的可达半年之久。</li><li>影子测试因为旁路在独立测试环境中进行，可以对生产流量完全无影响。</li><li>影子测试一般适用于遗留系统的等价重构迁移，例如.net转java，或者sqlserver数据库升级为mysql数据库，且外部依赖不能太多，否则需要开发很多mock，测试部署成本会很高，且比对测试更加复杂和不稳定。</li><li>当当网有一个比较成功的交易系统.net转java迁移项目[附录6.9]，采用了影子测试技术，值得参考借鉴。</li></ol><h5 id="优势和适用场合-7"><a href="#优势和适用场合-7" class="headerlink" title="优势和适用场合"></a>优势和适用场合</h5><p><strong>优势：</strong></p><ul><li>对生产用户体验完全无影响</li><li>可以使用生产真实流量进行测试（复制比对）</li></ul><p><strong>不足：</strong></p><ul><li>搭建复杂度很高，技术门槛高，数据库的导出复制是难点</li><li>外部依赖不能太多，否则测试部署成本很高，且比对测试更加复杂和不稳定</li></ul><p><strong>适用场合：</strong></p><ul><li>核心关键业务，比如涉及资金的</li><li>具备一定影子测试平台研发能力，包括流量复制、数据库导出复制和分发比对系统。</li></ul><h5 id="流量模式-7"><a href="#流量模式-7" class="headerlink" title="流量模式"></a>流量模式</h5><p><img src="/images/20180528/shadow_testing_traffic.png" alt="shadow testing traffic"></p><p>影子测试对生产流量无影响，图片来自[附录6.1]</p><h3 id="四、比较"><a href="#四、比较" class="headerlink" title="四、比较"></a>四、比较</h3><p>下表对各种发布策略，从各个维度进行综合比较，供参考：</p><p><img src="/images/20180528/comparision.png" alt="comparision"></p><h3 id="五、结论和建议"><a href="#五、结论和建议" class="headerlink" title="五、结论和建议"></a>五、结论和建议</h3><p>下面是对发布策略的一些选型建议，供不同阶段公司参考：</p><ol><li>蛮力发布一般是不建议采用的，除非是开发测试环境，用户体验不敏感的非关键应用，或者是创业期什么都缺时候的无奈之举。</li><li>如果暂时还不具备研发较复杂的滚动发布工具和配套智能LB，则功能开关是一种不错的轻量级发布技术，投入相对较小的成本，可以让研发人员灵活定制发布逻辑。</li><li>金丝雀发布通过少量新版本服务器接收生产流量的方式去验证新版本，可以显著降低风险。金丝雀发布适用于大部分场景，一般成长型公司就可以采用。</li><li>对于达到一定业务体量的公司，考虑到用户体验对业务的关键性，则需要投入研发资源开发支持滚动式发布的工具和配套的智能LB，实现自动化和零停机的发布。滚动式发布一般和金丝雀发布配合，先发一台金丝雀去验证流量，再按批次增量发布。</li><li>随着轻量级虚拟化（例如容器）的普及，双服务器组发布方式具有更快的发布和回退速度，是值得投入的高级发布技术。蓝绿部署仅适用于双服务器组，滚动式发布既可以在单服务器组上实现，也可以在双服务器组上实现。</li><li>对于涉及关键核心业务的新功能上线，采用A/B测试，可以显著降低发布风险，A/B测试是唯一一种支持针对特定用户组进行生产测试的高级发布技术。当然A/B测试的投入不低，建议有一定研发能力的组织采用。</li><li>对于关键核心业务的迁移重构，为确保万无一失，最后的一个大招是影子测试，影子测试对生产流量和用户完全无影响。当然这个大招的投入成本和门槛都高，建议有足够业务体量和研发能力的组织投入。</li><li>上述的各种发布策略并不是非此即彼的，一个公司常常会综合采用多种发布技术作为互补，实现灵活的发布能力。例如主流的发布手段是金丝雀+滚动式发布，某些业务线可能根据业务场景需要采用功能开关发布，还有一些业务线则可能采用高级的A/B测试发布手段。</li></ol><h3 id="六、附录"><a href="#六、附录" class="headerlink" title="六、附录"></a>六、附录</h3><ol><li><p><a href="https://github.com/ContainerSolutions/k8s-deployment-strategies" target="_blank" rel="noopener">k8s deployment strategies</a></p></li><li><p><a href="https://opensource.com/article/18/2/feature-flags-ring-deployment-model" target="_blank" rel="noopener">Deploying new releases: Feature flags or rings?</a></p></li><li><p><a href="https://github.com/ctripcorp/apollo" target="_blank" rel="noopener">携程Apollo配置中心</a></p></li><li><p><a href="http://www.ff4j.org/" target="_blank" rel="noopener">Feature Flag for Java</a></p></li><li><p><a href="https://launchdarkly.com/" target="_blank" rel="noopener">LaunchDarkly ~ Feature Flag as a Service</a></p></li><li><p><a href="https://github.com/intuit/wasabi" target="_blank" rel="noopener">Wasabi高级A/B测试平台</a></p></li><li><p><a href="https://blog.zenika.com/2017/04/19/migration-dun-legacy-avec-goreplay/" target="_blank" rel="noopener">使用goreplay实现遗留系统升级</a></p></li><li><p><a href="https://github.com/buger/goreplay" target="_blank" rel="noopener">Goreplay</a></p></li><li><p><a href="http://blog.shurenyun.com/untitled-9/" target="_blank" rel="noopener">华丽蜕变 – 当当网交易系统重构</a></p></li><li><p><a href="https://en.wikipedia.org/wiki/A/B_testing" target="_blank" rel="noopener">A/B Testing</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;根据2017年的DevOps发展报告，高效能组织和低效能组织在软件交付的效率上有数量级上的差异。技术组织的软件交付能力是一种综合能力，涉及众多环节，其中发布是尤为重要的环节。&lt;/p&gt;
&lt;p&gt;作为技术人员，大家可能听说过“滚动发布”和“蓝绿发布”等术语，但是很多人并不清楚这些术语背后的原理。本文试图总结当前主流的发布策略，每个的优劣，适用性，让开发人员特别是架构师对现代发布技术有一个更为清晰全面的认识，让大家能够根据自己的企业上下文，对发布策略做出正确的选型和实践。&lt;/p&gt;
    
    </summary>
    
      <category term="系统架构" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="发布模式" scheme="http://yoursite.com/tags/%E5%8F%91%E5%B8%83%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>中国式微服务技术栈2.0</title>
    <link href="http://yoursite.com/2018/05/27/20180527/"/>
    <id>http://yoursite.com/2018/05/27/20180527/</id>
    <published>2018-05-27T08:19:22.000Z</published>
    <updated>2018-06-15T12:18:24.157Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>近年，Spring Cloud俨然已经成为微服务开发的主流技术栈，在国内开发者社区非常火爆。我近年一直在一线互联网公司（携程，拍拍贷等）开展微服务架构实践，根据我个人的一线实践经验和我平时对Spring Cloud的调研，我认为Spring Cloud技术栈中的有些组件离生产级开发尚有一定距离。比方说Spring Cloud Config和Spring Cloud Sleuth都是Pivotal自研产品，尚未得到大规模企业级生产应用，很多企业级特性缺失（具体见我后文描述）。另外Spring Cloud体系还缺失一些关键的微服务基础组件，比如Metrics监控，健康检查和告警等。所以我在参考Spring Cloud微服务技术栈的基础上，结合自身的实战落地经验，也结合国内外一线互联网公司（例如Netflix，点评，携程，Zalando等）的开源实践，综合提出更贴近国内技术文化特色的轻量级的微服务参考技术栈。希望这个参考技术栈对一线的架构师（或者是初创公司）有一个好的指导，能够少走弯路，快速落地微服务架构。</p><a id="more"></a><p>这个参考技术栈和总体架构如下图所示：</p><p><img src="/images/20180527/msa_tech_stack.png" alt="msa tech stack"></p><p>中国式微服务技术栈1.0</p><p>主要包含11大核心组件，分别是：</p><p><strong>核心支撑组件:</strong></p><ol><li>服务网关Zuul</li><li>服务注册发现Eureka+Ribbon</li><li>服务配置中心Apollo</li><li>认证授权中心Spring Security OAuth2</li><li>服务框架Spring MVC/Boot</li></ol><p><strong>监控反馈组件:</strong></p><ol><li>数据总线Kafka</li><li>日志监控ELK</li><li>调用链监控CAT</li><li>Metrics监控KairosDB</li><li>健康检查和告警ZMon</li><li>限流熔断和流聚合Hystrix/Turbine</li></ol><h3 id="一、核心支撑组件"><a href="#一、核心支撑组件" class="headerlink" title="一、核心支撑组件"></a>一、核心支撑组件</h3><h4 id="1-1-服务网关Zuul"><a href="#1-1-服务网关Zuul" class="headerlink" title="1.1 服务网关Zuul"></a>1.1 服务网关Zuul</h4><p>2013年左右，infoq曾经对前Netflix架构总监Adrian Cockcroft有过一次专访[附录1]，其中有问Adrian：“Netflix开源这么多项目，你认为哪一个是最不可或缺的(MOST Indispensable)”，Adrian回答说：“在NetflixOSS开源项目中，有一个容易被忽略，但是Netflix最强大的基础服务之一，它就是Zuul网关服务。Zuul网关主要用于智能路由，同时也支持认证，区域和内容感知路由，将多个底层服务聚合成统一的对外API。Zuul网关的一大亮点是动态可编程，配置可以秒级生效”。从Adrian的回答中，我们可以感受到Zuul网关对微服务基础架构的重要性。</p><p><img src="/images/20180527/zuul.png" alt="zuul"></p><p>Zuul在英文中是一种怪兽，星际争霸中虫族里头也有Zuul，Netflix为网关起名Zuul，寓意看门神兽</p><p>Zuul网关在Netflix经过生产级验证，在纳入Spring Cloud体系之后，在社区中也有众多成功的应用。Zuul网关在携程（日流量超50亿），拍拍贷等公司也有成功的落地实践，是微服务基础架构中网关一块的首选。其它开源产品像Kong或者Nginx等也可以改造支持网关功能，但是较复杂门槛高一点。</p><p>Zuul网关虽然不完全支持异步，但是同步模型反而使它简单轻量，易于编程和扩展，当然同步模型需要做好限流熔断（和限流熔断组件Hystrix配合），否则可能造成资源耗尽甚至雪崩效应（cascading failure）。</p><h4 id="1-2-服务注册发现Eureka-Ribbon"><a href="#1-2-服务注册发现Eureka-Ribbon" class="headerlink" title="1.2 服务注册发现Eureka + Ribbon"></a>1.2 服务注册发现Eureka + Ribbon</h4><p>针对微服务注册发现场景，社区里头的开源产品当中，经过生产级大流量验证的，目前只有Netflix Eureka一个，它也已经纳入Spring Cloud体系，在社区中有众多成功应用，例如携程Apollo配置中心也是使用Eureka做软负载。其它产品如Zookeeper/Etcd/Consul等，都是比较通用的产品，还需要进一步封装定制才可生产级使用。Eureka支持跨数据中心高可用，但它是AP最终一致系统，不是强一致性系统。</p><p><img src="/images/20180527/eureka.jpg" alt="eureka"></p><p>Eureka是阿基米德洗澡时发现浮力原理时发出的惊叹声，在微服务中寓意发现</p><p>Ribbon是可以和Eureka配套对接的客户端软负载库，在Eureka的配合下能够支持多种灵活的动态路由和负载均衡策略。内部微服务直连可以直接走Ribbon客户端软负载，网关上也可以部署Ribbon，这时网关相当于一个具有路由和软负载能力的超级客户端。</p><p><img src="/images/20180527/ribbon.png" alt="ribbon"></p><p>Ribbon是蝴蝶结的意思</p><h4 id="1-3-服务配置中心Apollo"><a href="#1-3-服务配置中心Apollo" class="headerlink" title="1.3 服务配置中心Apollo"></a>1.3 服务配置中心Apollo</h4><p>Spring Cloud体系里头有个Spring Cloud Config产品，但是功能远远达不到生产级，只能小规模场景下用，中大规模企业级场景不建议采用。携程框架研发部开源的Apollo是一款在携程和其它众多互联网公司生产落地下来的产品，开源两年多，目前在github上有超过4k星，非常成功，文档齐全也是它的一大亮点，推荐作为企业级的配置中心产品。Apollo支持完善的管理界面，支持多环境，配置变更实时生效，权限和配置审计等多种生产级功能。Apollo既可以用于连接字符串等常规配置场景，也可用于发布开关（Feature Flag）和业务配置等高级场景。在《2018波波的微服务基础架构和实践》课程中，第二个模块就配置中心相关主题，会深度剖析携程Apollo的架构和实践，预计6月份推出，欢迎大家关注学习。</p><p><img src="/images/20180527/apollo.png" alt="apollo"></p><p>阿波罗是希腊神话中太阳神的意思</p><h4 id="1-4-认证授权中心Spring-Security-OAuth2"><a href="#1-4-认证授权中心Spring-Security-OAuth2" class="headerlink" title="1.4 认证授权中心Spring Security OAuth2"></a>1.4 认证授权中心Spring Security OAuth2</h4><p>目前开源社区还没有特别成熟的微服务安全认证中心产品，之前我工作过的一些中大型互联网公司，比如携程，唯品会等，在这一块基本都是定制自研的，但是对一般企业来说，定制自研还是有门槛的。OAuth2是一种基于令牌Token的授权框架，已经得到众多大厂（Google, Facebook, Twitter, Microsoft等）的支持，可以认为是事实上的微服务安全协议标准，适用于开放平台联合登录，现代微服务安全（包括单页浏览器App/无线原生App/服务器端WebApp接入微服务，以及微服务之间调用等场景），和企业内部应用认证授权(IAM/SSO)等多种场景。</p><p>Spring Security OAuth2是Spring Security基础上的一个扩展，支持四种主要的OAuth2 Flows，基本可以作为微服务认证授权中心的推荐产品。但是Spring Security OAuth2还只是一个框架，不是一个端到端的开箱即用的产品，企业级应用仍需在其上进行定制，例如提供Web端管理界面，对接企业内部的用户认证登录系统，使用Cache缓存令牌，和微服务网关对接等，才能作为生产级使用。在波波在极客时间的《微服务架构实践160讲》课程中，第一个模块就是微服务安全架构和实践相关主题，会深度剖析OAuth2原理和Spring Security OAuth2实践，欢迎大家关注学习。</p><p><img src="/images/20180527/spring_security_oauth2.png" alt="spring security oauth2"></p><p>Spring Security OAuth2是Spring Security框架的一个扩展</p><h4 id="1-5-服务框架Spring-Boot"><a href="#1-5-服务框架Spring-Boot" class="headerlink" title="1.5 服务框架Spring Boot"></a>1.5 服务框架Spring Boot</h4><p>Spring可以说是史上最成功的Web App/API开发框架之一，它融入了Java社区中多年来沉淀下来的最佳实践，虽然有将近15年历史，但目前的社区活跃度仍呈上升趋势。Spring Boot在Spring的基础上进一步打包封装，提供更贴心的Starter工程，自启动能力，自动依赖管理，基于代码的配置等特性进一步降低接入门槛。另外Spring Boot也提供actuator这样的生产级监控特性，支持DevOps研发模式，它是微服务开发框架的推荐首选。</p><p>REST契约规范Swagger和Spring有比较好的集成，使得Spring也支持契约驱动开发(Contract Driven Development)模型。对于一些中大规模的企业，如果业务复杂团队较多，考虑到互操作性和集成成本，建议采用契约驱动开发模型，也就是开发时先定义Swagger契约，然后再通过契约生成服务端接口和客户端，再实现服务端业务逻辑，这种开发模型能够标准化接口，降低系统间集成成本，对于多团队协同并行开发非常重要。</p><p><img src="/images/20180527/spring_boot_logo.jpg" alt="spring boot logo"></p><p>Spring Boot Logo</p><h3 id="二、监控反馈组件"><a href="#二、监控反馈组件" class="headerlink" title="二、监控反馈组件"></a>二、监控反馈组件</h3><h4 id="2-1-数据总线Kafka"><a href="#2-1-数据总线Kafka" class="headerlink" title="2.1 数据总线Kafka"></a>2.1 数据总线Kafka</h4><p>最初由Linkedin研发并在其内部大规模成功应用，然后在Apache上开源的Kafka，是业内数据总线(Databus)一块的标配，几乎每一家互联网公司都可以看到Kafka的身影。Kafka堪称开源项目的一个经典成功案例，其创始人团队从Linkedin离职后还专门成立了一家叫confluent的企业软件服务公司，围绕Kafka周边提供配套和增值服务。在监控一块，日志和Metrics等数据可以通过Kafka做收集、存储和转发，相当于中间增加了一个大容量缓冲，能够应对海量日志数据的场景。除了日志监控数据收集，Kafka在业务大数据分析，IoT等场景都有广泛应用。如果对Kafka进行适当定制增强，还可以用于传统消息中间件场景。</p><p>Kafka的特性是大容量，高吞吐，高可用，数据可重复消费，可水平扩展，支持消费者组等。Kafka尤其适用于不严格要求实时和不丢数据的大数据日志场景。</p><p><img src="/images/20180527/kafka_founders.jpg" alt="kafka founders"></p><p>Kafka创始人三人组，离开Linkedin后，创立了基于Kafka的创业公司Confluent</p><h4 id="2-2-日志监控ELK"><a href="#2-2-日志监控ELK" class="headerlink" title="2.2 日志监控ELK"></a>2.2 日志监控ELK</h4><p>ELK（ElasticSearch/Logstash/Kibana）是日志监控一块的标配技术栈，几乎每一家互联网公司都可以看到ELK的身影，据称携程是国内ELK的最大用户，每日增量日志数据量达到80~90TB。ELK已经非常成熟，基本上是开箱即用，后续主要的工作在运维、治理和调优。ELK一般和Kafka配套使用，因为日志分词操作还是比较耗时的，Kafka主要作为前置缓冲，起到流量消峰作用，抵消日志流量高峰和消费（分词建索引）的不匹配问题。一旦反向索引建立，日志检索是非常快的，所以日志检索快和灵活是ElasticSearch的最大亮点。另外ELK还有大容量，高吞吐，高可用，可水平扩容等企业级特性。</p><p>创业公司起步期，考虑到资源时间限制，调用链监控和Metrics监控可以不是第一优先级，但是ELK是必须搭一套的，应用日志数据一定要收集并建立索引，基本能够覆盖大部分Trouble Shooting场景（业务，性能，程序bug等）。另外用好ELK的关键是治理，需要制定一些规则（比如只收集Warn级别以上日志），对应用的日志数据量做好监控，否则开发人员会滥用，什么垃圾数据都往ELK里头丢，造成大量空间被浪费，严重的还可能造成性能可用性问题。</p><p><img src="/images/20180527/elk_kafka_deployment.png" alt="elk kafka deployment"></p><p>ELK + Kafka参考部署架构</p><h4 id="2-3-调用链监控CAT"><a href="#2-3-调用链监控CAT" class="headerlink" title="2.3 调用链监控CAT"></a>2.3 调用链监控CAT</h4><p>Spring Cloud支持基于Zipkin的调用链监控，我个人基于实践经验认为Zipkin还不能算一款企业级调用链监控产品，充其量只能算是一个半成品，很多重要的企业级特性缺失。Zipkin最早是由Twitter在消化Google Dapper论文的基础上研发，在Twitter内部有较成功应用，但是在开源出来的时候把不少重要的统计报表功能给阉割了（因为依赖于一些比较重的大数据分析平台），只是开源了一个半成品，能简单查询和呈现可视化调用链，但是细粒度的调用性能数据报表没有开源。</p><p>Google大致在2007年左右开始研发称为Dapper的调用链监控系统，但在远远早于这个时间（大致在2002左右），eBay就已经有了自己的调用链监控系统CAL（Centralized Application Logging），Google和eBay的设计思路大致相同，但是也有一些差别。CAL在eBay有大规模成功应用，被称为是eBay的四大神器之一（另外三个是DAL，Messaging和SOA）。开源调用链监控系统CAT的作者吴其敏（我曾经和他同事，习惯叫他老吴），曾经在eBay工作近十年，期间深入消化吸收了CAL的设计。2011年后老吴离开eBay去了点评，用三年时间在点评再造了一款调用链监控产品CAT（Centralized Application Tracking），CAT具有CAL的基因和影子，同时也融入了老吴在点评的探索实践和创新。</p><p>CAT是一款更完整的企业级调用链监控产品，甚至已经接近一个APM（Application Performance Management）产品的范畴，它不仅支持调用链的查询和可视化，还支持细粒度的调用性能数据统计报表，这块是CAT和市面上其它开源调用链监控产品最本质的差异点，实际上开发人员大部分时间用CAT是看性能统计报表（主要是CAT的Transaction和Problem报表），这些报表相当于给了开发人员一把尺子，可以自助测量并持续改进应用性能。另外CAT还支持应用报错大盘，自助告警等功能，也是企业级监控非常实用的功能。</p><p>CAT在点评，携程，陆金所，拍拍贷等公司有成功落地案例，因为是国产调用链监控产品，界面展示和功能等更契合国内文化，更易于在国内公司落地。个人推荐CAT作为微服务调用链监控的首选。至于社区里头有人提到CAT的侵入性问题，我觉得是要一分为二看，有利有弊，有耦合性但是性能更好，一般企业中基础架构团队会使用CAT统一为基础组件埋点，开发人员一般不用自己埋点；另外企业用了一款调用链监控产品以后，一般是不会换的，开发人员用习惯就好了，侵入不是大问题。</p><p><img src="/images/20180527/cat_transaction.png" alt="cat transaction"></p><p>cAT的Transaction报表</p><h4 id="2-4-Metrics监控KairosDB"><a href="#2-4-Metrics监控KairosDB" class="headerlink" title="2.4 Metrics监控KairosDB"></a>2.4 Metrics监控KairosDB</h4><p>除了日志和调用链，Metrics也是应用监控的重要关注点。互联网应用提倡度量驱动开发（Metrics Driven Development），也就是说开发人员不仅要关注功能实现，做好单元测试（TDD），还要做好业务层（例如注册，登录和下单数等）和应用层（例如调用数，调用延迟等）的监控埋点，这个也是DevOps（开发即运维）理念的体现，DevOps要求开发人员必须关注运维需求，监控埋点是一种生产级运维需求。</p><p>Metrics监控产品底层依赖于时间序列数据库（TSDB），最近比较热的开源产品有Prometheus和InfluxDB，社区用户数量和反馈都不错，可以采纳。但是这些产品分布式能力比较弱，定制扩展门槛比较高，一般建议刚起步量不大的公司采用。如果企业业务和团队规模发展到一定阶段，建议考虑支持分布式能力的时间序列监控产品，例如KairosDB或者OpenTSDB，我本人对这两款产品都有一些实践经验，KariosDB基于Cassandra，相对更轻量一点，建议中大规模公司采用，如果你们公司已经采用Hadoop/HBase，则OpenTSDB也是不错选择。</p><p>KairosDB一般也和Kafka配套使用，Kafka作为前置缓冲。另外注意使用KariosDB打点的话tag的值不能太离散，否则会有查询性能问题，这个和KariosDB底层存储结构有关系。Grafana是Metrics展示标配，可以和KariosDB无缝集成。</p><p><img src="/images/20180527/grafana.png" alt="grafana"></p><p>Grafana是Metrics展示标配，和主流时间序列数据库都可以集成</p><h4 id="2-5-健康检查和告警ZMon"><a href="#2-5-健康检查和告警ZMon" class="headerlink" title="2.5 健康检查和告警ZMon"></a>2.5 健康检查和告警ZMon</h4><p>除了上述监控手段，我们仍需要健康检查和告警系统作为配套的监控手段。ZMon是德国电商公司Zalando开源的一款健康检查和告警平台，具备强大灵活的监控告警能力。ZMon本质上可以认为是一套分布式监控任务调度平台，它提供众多的Check脚本（也可以自己再定制扩展），能够对各种硬件资源或者目标服务（例如HTTP端口，Spring的Actuator端点，KariosDB中的Metrics，ELK中的错误日志等等）进行定期的健康检查和告警，它的告警逻辑和策略采用Python脚本实现，开发人员可以实现自助式告警。ZMon同时适用于系统，应用，业务，甚至端用户体验层的监控和告警。</p><p><img src="/images/20180527/zmon_architecture.png" alt="zmon architecture"></p><p>ZMon分布式监控告警系统架构，底层基于KairosDB时间序列数据库</p><h4 id="2-6-限流熔断和流聚合Hystrix-Turbine"><a href="#2-6-限流熔断和流聚合Hystrix-Turbine" class="headerlink" title="2.6 限流熔断和流聚合Hystrix+Turbine"></a>2.6 限流熔断和流聚合Hystrix+Turbine</h4><p>2010年左右，Netflix也饱受分布式微服务系统中雪崩效应（Cascading Failure）的困扰，于是专门启动了一个叫做弹性工程的项目来解决这个问题，Hystrix就是弹性工程最终落地下来的一个产品。Hystrix在Netflix微服务系统中大规模推广应用后，雪崩效应问题基本得到解决，整个体统更具弹性。之后Netflix把Hystrix开源贡献给了社区，短期获得社区的大量正面反馈，目前Hystrix在github上有超过1.3万颗星，据说支持奥巴马总统选举的系统也曾使用Hystrix进行限流熔断保护[参考附录2]，可见限流熔断是分布式系统稳定性的强需求，Netflix很好的抓住了这个需求并给出了经过生产级验证的解决方案。Hystrix已经被纳入Spring Cloud体系，它是Java社区中限流熔断组件的首选（目前还看不到第二个更好的产品）。</p><p>Turbine是和Hystrix配套的一个流聚合服务，能够对Hystrix监控数据流进行聚合，聚合以后可以在Hystrix Dashboard上看到集群的流量和性能情况。</p><p><img src="/images/20180527/hystrix.png" alt="hystrix"></p><p>Hystrix在英文中是豪猪兽的意思，豪猪兽通过身上的刺保护自己，Netflix为限流熔断组件起名Hystrix，寓意Hystrix能够保护微服务调用。</p><h3 id="三、结论"><a href="#三、结论" class="headerlink" title="三、结论"></a>三、结论</h3><ol><li>技术栈没有好坏之分，只有适合一说。本文推荐的技术栈主要基于我个人的实践和总结，但是未必适合所有场景，毕竟每个企业的上下文各不相同。作为架构师你可以参考我推荐的技术栈，但不可拘泥照搬，你必须在深入理解分布系统原理的基础上，再结合企业实际场景灵活应用。</li><li>本文推荐的技术栈主要面向微服务基础架构，也是波波在极客时间上的《微服务架构实践160讲》课程要深度剖析的主题。在整个互联网基础技术平台体系中，还有消息，任务，数据访问层，发布系统，容器云平台，分布式事务，分布式一致性，测试，CI/CD等其它重要主题，这些是波波在2019第三季和2020第四季在极客时间上要陆续推出的内容，请大家持续关注。</li><li>2018年波波在极客时间上的课程《微服务架构实践160讲》约有8个模块化课程组成，每个模块专注剖析微服务基础架构的一个核心组件，技术人员可以在碎片化时间自由学习，快速掌握微服务核心组件的问题域、架构原理和开发运维实践。对开发人员和架构师的个人能力提升和职业发展收益主要包括：<ul><li>对主流微服务技术栈的组件及其架构有较全面深入的理解，</li><li>对微服务基础架构有体系化认识，</li><li>能够根据企业场景设计和搭建微服务基础架构，</li><li>中高级程序员可以向架构师行列迈进，</li><li>现有架构师可以充实和拓展基础架构知识和技能体系。</li></ul></li></ol><h3 id="四、附录"><a href="#四、附录" class="headerlink" title="四、附录"></a>四、附录</h3><ol><li><p><a href="https://www.infoq.com/articles/cockcroft-high-availability" target="_blank" rel="noopener">Interview: Adrian Cockcroft on High Availability, Best Practices, and Lessons Learned in the Cloud</a></p></li><li><p><a href="http://it.sohu.com/20121129/n358943361.shtml" target="_blank" rel="noopener">Netflix云端开源工具Hystrix：曾助奥巴马竞选</a></p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;近年，Spring Cloud俨然已经成为微服务开发的主流技术栈，在国内开发者社区非常火爆。我近年一直在一线互联网公司（携程，拍拍贷等）开展微服务架构实践，根据我个人的一线实践经验和我平时对Spring Cloud的调研，我认为Spring Cloud技术栈中的有些组件离生产级开发尚有一定距离。比方说Spring Cloud Config和Spring Cloud Sleuth都是Pivotal自研产品，尚未得到大规模企业级生产应用，很多企业级特性缺失（具体见我后文描述）。另外Spring Cloud体系还缺失一些关键的微服务基础组件，比如Metrics监控，健康检查和告警等。所以我在参考Spring Cloud微服务技术栈的基础上，结合自身的实战落地经验，也结合国内外一线互联网公司（例如Netflix，点评，携程，Zalando等）的开源实践，综合提出更贴近国内技术文化特色的轻量级的微服务参考技术栈。希望这个参考技术栈对一线的架构师（或者是初创公司）有一个好的指导，能够少走弯路，快速落地微服务架构。&lt;/p&gt;
    
    </summary>
    
      <category term="微服务架构" scheme="http://yoursite.com/categories/%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="技术选型" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
    
      <category term="微服务" scheme="http://yoursite.com/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>波波的技术选型哲学</title>
    <link href="http://yoursite.com/2018/05/25/20180525/"/>
    <id>http://yoursite.com/2018/05/25/20180525/</id>
    <published>2018-05-25T03:24:35.000Z</published>
    <updated>2018-06-15T12:21:20.806Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>技术选型是一个很热门的话题，最近我看到自己的微信朋友圈有好几篇关于技术选型的文章，读者对这类主题的热情很高。在技术组织内部，技术人员经常会面临技术选型问题，有时候，技术选型还常常牵扯好几波干系人，相互之间还会产生争议，有的甚至还可能发展到派系斗争的地步。即便像我自己，已经有十几年研发和架构经验的老司机，不管是工作还是业余，有很大部分时间的思考都是深陷在A技术和B技术的利弊权衡之中，不能自拔。无论如何，技术选型说小了关乎项目和团队成败，说大了关乎企业业务的发展，不可小觑。</p><p>本文所表达的技术选型理念应该是具体技术无关的，但是由于我个人的背景更偏向互联网后端的研发和架构，所以本文的视角更偏向后端技术的选型。</p><a id="more"></a><h3 id="一、软件的本质复杂性"><a href="#一、软件的本质复杂性" class="headerlink" title="一、软件的本质复杂性"></a>一、软件的本质复杂性</h3><p>近年，云计算、微服务、容器和DevOps等新技术和理念层出不穷，技术人员对各种新技术的追捧热情也空前高涨，各种新技术微信讨论群也如雨后春笋般冒了出来。这是一个好现象，说明我们的开发人员多了，技术环境也日趋成熟，有点百花齐放的感觉。同时也让我有一点担忧，我担忧的是纯技术和工具论的抬头，也就是太过专注技术，认为技术可以搞定一切，反而忽略了软件研发的本质复杂性。回想当年，自己也曾是这样的技术狂热分子，EJB刚出来的时候，我为EJB摇旗呐喊，Spring出来的时候，我也曾一度是该技术的死忠，简单认为这些技术是银弹可以帮助解决所有的复杂性问题。</p><p>1986年，人月神话的作者Brooks就提出，软件的本质复杂性（Essential Complexity）存在于复杂的业务领域中（用技术的话讲是业务领域建模复杂性），技术仅是辅助工具，它解决的问题是帮助将业务领域问题映射转换成软件实现，只解决次要复杂性（Accidental Complexity）。作者同时指出，由于软件本质的复杂性，真正的银弹并不存在；也断言在十年内，没有任何一项技术或者方法可使软件工程的生产力提高一个数量级。30年前作者提出的论断，今天依然闪烁智慧的光芒。人月神话已经出了40周年纪念版了，堪称软件工程的圣经，建议所有从事软工行业的朋友学习。除了业务和技术，我还想强调软件的本质复杂性同时隐含在企业的人、组织、流程和管理中，不容忽视。</p><p>架构师只有深刻理解软件的本质复杂性，才能站在解决实际业务问题的角度，更好的做出技术选型，否则易陷入唯技术工具论的陷阱。</p><p><img src="/images/20180525/mythical_man_month.jpg" alt="mythical man month"></p><h3 id="二、使用成熟的技术"><a href="#二、使用成熟的技术" class="headerlink" title="二、使用成熟的技术"></a>二、使用成熟的技术</h3><p>大部分公司都是商业组织，不是科研机构或者纯软件研发机构。商业组织使用技术是为了解决当下的业务问题，他们更应该使用成熟稳定的技术。</p><p>如下图，技术的使用有明显的生命周期，早期有创新者和早期使用者采用，我把这个阶段称为试水趟坑期，也就是说这个阶段技术不是很成熟稳定的，虽然尝新者可能占据一定的技术领先优势，但是他们常常需要以踩坑填坑作为代价；如果这项技术经过早期验证则会跨越鸿沟进入早期大众阶段，这个阶段技术会逐渐走向成熟，处于上升期，坑逐渐被填平，技术被大众所采纳；之后技术缓慢经过末期大众阶段，最终走向滞后期，一直到生命周期的结束退出历史舞台。</p><p><img src="/images/20180525/tech_adoption.jpg" alt="technology adoption life cycle"></p><p>技术选型的一大智慧是不要盲目追求新技术，老老实实采用成熟稳定的技术，让那些喜欢追新的人去踩坑😊，等这项技术跨越鸿沟，进入早期大众阶段，你再择机投入，这样最保险和高效。当然作为技术人员，对新技术保持敏锐，提前预研是完全OK的，但是投入生产的话还是成熟稳定第一。</p><h3 id="三、少即是多"><a href="#三、少即是多" class="headerlink" title="三、少即是多"></a>三、少即是多</h3><p>一项新技术既有学习成本，又有维护（定制、监控、管理和运维）成本，新技术引入很容易，学好用好运维好却很难。一个不严格把控技术栈数量的公司，开发人员常常会各自为政，随意引入新技术，造成技术栈散乱，学习和维护成本高，技术栈知识无法共享，技术体系无法建立等问题，严重的会极大影响研发效率和业务规模化能力。</p><p>以我本人专注的后端基础框架领域为例，技术栈散乱还会直接影响系统稳定性，因为技术组件和工具太多，无法统一埋点和建立完善的监控体系。当业务量发展到一定规模，技术栈散乱还会给系统扩容跨机房迁移等带来巨大障碍。</p><p>在一些成熟的互联网公司，比如国内的阿里，国外的Netflix和eBay等公司，这些公司虽然财力和资源丰富，但是他们的核心技术栈（比如主流开发语言，框架和数据存储等）的数量同样是受到严格把控的。</p><p>新技术引入的基本原则就是少即是多，能不引入新技术尽量不要引入新技术，确实需要引入的话，也要有相应的新技术引入管理流程（一般由公司的技术或者架构委员会制定和把控）。</p><h3 id="四、技术的先决条件"><a href="#四、技术的先决条件" class="headerlink" title="四、技术的先决条件"></a>四、技术的先决条件</h3><p>技术引入常常是有一些先决条件的，比方说最近比较热的微服务架构，按照马丁福勒的说法，微服务有如下先决条件：</p><ul><li>快速的环境提供能力（Provisioning）能力（通常指IAAS层能力），</li><li>基本的监控能力</li><li>快速的发布能力</li><li>初步的DevOps文化</li></ul><p>马丁特别指出“你必须长足够高才能考虑微服务”，在这些先决条件没有满足之前，直接推行微服务会面临巨大落地挑战。</p><p><img src="/images/20180525/tech_prerequisite.jpg" alt="tech prerequisite"></p><p>同样，容器技术的引入对应用也是有要求的（参考[<a href="#appendix">附录17.1</a>] ~ 12 Factor App），而DevOps研发模式的引入不仅对基础技术和架构，研发人员技能，甚至组织架构和企业文化都是有很高要求的，在没有满足先决条件前，这些新技术或研发模式都会面临巨大的落地挑战。</p><p>作为管理者或者架构师，在引入一项新技术之前，要充分调研了解新技术的先决条件，不能盲目引入。对于确实需要引入但是目前还不满足先决条件的，需要做好阶段性规划，先打好基础，再适时引入新技术。</p><h3 id="五、来自大公司的技术"><a href="#五、来自大公司的技术" class="headerlink" title="五、来自大公司的技术"></a>五、来自大公司的技术</h3><p>大公司采用的技术，未必适合中小公司。大公司有足够的资源、人力和时间，可以投入一些前沿和重量级的技术（在BAT级别公司，为重量级技术投入几十甚至百人以上的研发团队是很正常的事），但是中小公司资源有限，不能盲目跟风，应该选择和自己发展阶段相适应的技术，否则不仅不能帮助业务发展，反而会给业务发展带来阻碍。</p><h3 id="六、技术的文化特性"><a href="#六、技术的文化特性" class="headerlink" title="六、技术的文化特性"></a>六、技术的文化特性</h3><p>技术常常带有文化特性的，在国外流行的技术，在国内未必流行。一个例子是如Scala这样的函数式语言，Scala在国外互联网公司是有一定流行度的（Twitter、Linkedin等），国内虽然有不少簇拥者，但是始终只是小众，无法流行，究其原因，国外很多大学教授的第一门编程语言是采用函数式语言的（例如美国Berkeley大学的CS61A是基于Scheme函数式语言），国内大学几乎清一色采用C/C++/Java等命令式语言作为第一门编程语言。也就是说函数式语言在国外是有文化基础的，所以容易流行，国内没有这样的文化基础，所以难以流行。</p><p>我们在选型的时候，尽量采用在国内有文化基础，已经落地开花的技术，盲目追求国外新技术有可能文化不适应反而难于落地。</p><p>同样的，在A公司流行的技术，在B公司也未必流行。比方说BAT三家公司所采用和后面演化出来的技术栈就明显不同，这同样和三家公司不同的业务领域和文化基因有关系。我们在做技术选型的时候，也要考虑公司的文化特性，如业务模式、已有技术生态和开发人员技能等现实情况。</p><h3 id="七、开源还是第三方软件提供商的技术"><a href="#七、开源还是第三方软件提供商的技术" class="headerlink" title="七、开源还是第三方软件提供商的技术"></a>七、开源还是第三方软件提供商的技术</h3><p>互联网时代，传统的企业软件供应商开始明显地走下坡路，企业越来越多的采用开源技术来开发他们的业务系统，开源软件具有如下优势：</p><ol><li>成本，商业软件一般有昂贵的license费用；</li><li>避免供应商绑定(vendor lockin)；</li><li>灵活的定制能力，现代企业需要灵活的软件定制能力以应对快速变化的用户需求，商业闭源软件常常缺乏这种能力；</li><li>社区和生态，投资具有良好社区和生态的开源技术是企业技术选型的最佳实践。</li></ol><p>即使是开源软件，这里面有一个很重要的闭环问题。有些开源软件是一线互联网公司成功落地后再开源出来的，比如阿里的dubbo，点评的CAT，这些公司本身有场景，内部大量使用，也就是说内部已经形成反馈闭环，开源出来和社区又形成了一个更大的反馈闭环。有一些第三方软件供应商提供的开源软件，其实他们本身是没有业务场景的（或者场景非常有限），主要靠社区使用后才能形成反馈闭环，对于这类开源软件的使用需要谨慎，如果选择的话，可能需要一起帮忙踩坑形成社区反馈闭环。</p><h3 id="八、使用能掌控的技术"><a href="#八、使用能掌控的技术" class="headerlink" title="八、使用能掌控的技术"></a>八、使用能掌控的技术</h3><p>技术和武器一样，并不是说越先进越好。就像航空母舰和F117这样的尖端武器，确实非常厉害，但是掌握和部署运维这些武器的成本非常之高，如果你的团队没有足够的能力运维和掌控这样的武器，那么这些武器摆在家里充其量只能是摆设，不能形成战斗力，有时甚至还会拖累业务。</p><p>在大数据领域重量级武器尤其多（Hadoop, HBase, Spark, Storm…），很多产品既消耗机器资源，部署和运维也非常复杂，如果某种重量级武器被应用在关键业务上，一旦出问题，团队能不能hold住是要重点考虑的，否则可能会死得很难看。架构师需要根据业务阶段规模，团队规模和技能水平，综合评估后再考虑引入，如果团队能力还不足以掌控某种重量级技术，则可以先从轻量级技术开始。</p><h3 id="九、剑要交给懂得挥舞它的人"><a href="#九、剑要交给懂得挥舞它的人" class="headerlink" title="九、剑要交给懂得挥舞它的人"></a>九、剑要交给懂得挥舞它的人</h3><p>同一种技术，不同的人使用，可能会得出完全相反的结论。比如Cassandra这种NoSql分布式数据库，在Netflix有比较成功的应用，Netflix从2010开始将系统迁移到AWS云中，并开始将大部分业务数据从传统Oracle数据库迁移到Cassandra上，Netflix的前架构总监Adrian Cockcroft把他们技术升级的一大成功功劳归结为采用了Cassandra这种天然支持跨数据中心的分布式数据库。但是，在2012年时候，Digg在网站改版升级过程中也试图将传统Mysql数据库迁移到Cassandra Nosql数据库，结果导致Digg网站问题频发，最后技术副总裁John Quinn主动卷铺盖走人。事后，有人将问题归结为Cassandra，这就是著名的Digg使用Cassandra遭遇滑铁卢事件。有人在Quora上发帖提问“Is Cassandra to blame for Digg v4’s technical failures？”[<a href="#appendix">附录17.2</a>]，回帖中有知情人士出来澄清：把Digg网站升级失败归结为Cassandra完全是转移注意力（red herring），背后的真正原因是工程管理和架构的问题（poor engineering management and architecture），简单讲就是人的问题。</p><p>我曾经在2013年左右在携程框架部工作，当时有一个很重要的框架产品叫分布式数据访问层DAL，很多团队都跃跃欲试要做，但是当时的CTO一直没有正式启动这个项目，理由是没有合适的人。这个事情拖了有一年之久才找到合适的人，这个项目才启动并逐步落地，现在已经是携程框架的关键基础设施，承载携程大部分数据库访问流量。</p><p>对于一些重量级的，处于业务关键链路上的产品，如果它重要但不紧急的话，一定要找到并交给能搞定它的人。把一个重要产品交给一个不合适的人，不仅不能解决问题，后续还常常会制造问题。设想一下业务的关键链路上的某个关键产品质量不过关，问题频发，但是业务已经跑在上面无法简单替换，这是让人很无奈的事情，很多架构老司机对此场景应该深有体会吧。</p><h3 id="十、浪费是创新的副产品"><a href="#十、浪费是创新的副产品" class="headerlink" title="十、浪费是创新的副产品"></a>十、浪费是创新的副产品</h3><p>即使在同一个公司中，在主流技术栈的基础上，不同团队适当引入一些不同的技术栈，比如一个公司主流的技术栈是Java，有些前端团队会尝试用Nodejs开发应用，有些大数据团队会采用Python开发应用（Python里头有很多数据分析库）。这些做法和第二点提出的少即是多并不矛盾，根据业务场景的需要，适当引入一些互补的技术栈，适度冗余可以促进团队创新。</p><p>再举个例子，阿里在发展的过程中，曾经发展出两套技术体系，一套是淘宝体系，一套是B2B体系。有一段时间内，两套体系并行发展，团队之间既竞争也相互借鉴，形成一个良性竞争的技术生态。据说Dubbo最早就是B2B搞出来的，淘宝后面又搞了一套HSF（未开源），Dubbo和HSF之间相互借鉴所以功能比较类似，阿里在2014年上市前对技术栈进行了整合，集团统一使用HSF，Dubbo则继续活跃在开源社区，成为中国开源软件的一个传奇，它的成功一方面源自阿里技术的沉淀，另一方面也是B2B和淘宝相关团队思路碰撞融合的结果。</p><h3 id="十一、技术的宗教信仰"><a href="#十一、技术的宗教信仰" class="headerlink" title="十一、技术的宗教信仰"></a>十一、技术的宗教信仰</h3><p>很多技术人员对他们投入时间最多最熟悉的技术栈比较热衷，有些甚至能上升到宗教信仰的程度，不同派系还会有相互鄙视的情况出现（据说PHP是最被鄙视的语言），有的还会发展到派系争斗的地步。之前我在一家互联网公司，在容器PaaS平台选型上出现了两个派系，分别被戏称为K党和M党，K党主张引入谷歌推的Kubernetes，M党主张基于Mesos做定制，两拨人都非常坚持互不相让，争得不可开交。</p><p>其实我个人对技术的宗教信仰是非常排斥的，它是一种技术视野狭隘的表现，技术本身没有绝对的好坏之分，只有适用场景和利弊之分。但是，技术的宗教信仰是一种客观存在，有经验的架构师在做技术选型时需要考虑这一层面的因素。</p><h3 id="十二、通过背书做技术选型"><a href="#十二、通过背书做技术选型" class="headerlink" title="十二、通过背书做技术选型"></a>十二、通过背书做技术选型</h3><p>和一线资深的架构师或者技术专家交流，获取技术选型的专家建议，是一种比较靠谱的技术选型策略。专家是一种背书，他们踩坑无数才成为专家，对很多技术有一手的实战经验，是真正know how的人，所以他们给出的建议一般都比较接地气。</p><p>大公司是一个很好的背书，比方说Google，当初它推出Kubernetes的时候，其实我一开始看过架构设计之后是对这个产品嗤之以鼻的。但是Google的强大背书和号召力摆在那里，用户深信Google用脚投票，一开始架构设计不好不是根本性问题，只要有足够的用户形成社区闭环，这个产品就会不断长好长大。目前K8S已经基本垄断了容器PaaS平台市场，它的成功很大程度归结为Google公司的背书影响力。所以，绑着技术型大公司这个背书做技术选型，大概率不至于大错（当然不是绝对）。</p><p>Github上的星的数量也是一个重要的技术选型参考，同时还有项目代码和文档更新频度（尤其是近期），这些指标直接反应开源项目的社区活跃度和生命力。</p><h3 id="十三、实践出真知"><a href="#十三、实践出真知" class="headerlink" title="十三、实践出真知"></a>十三、实践出真知</h3><p>实际评估一项技术时，最靠谱的做法还是详细研究其文档，做一些样例和测试，对性能有要求的则必须实际做充分压力测试获得真实性能数据。对于开源的产品，如果处在业务的关键链路上，则建议把代码拉下来通读梳理一把，深入理解其内部设计和架构，有的还需要根据企业业务场景适当做一些定制。</p><p>通过初步评估，仍需要寻找一定数量非关键试点项目（pilot project）做试水躺坑，经过初步生产验证，才可以考虑逐步扩大生产普及的规模。</p><p>实践出真知，对于那些长期在一线实战和积累的架构师，他们最终将获得良好的技术选型的sense和对新技术的敏锐性。</p><h3 id="十四、技术的落地"><a href="#十四、技术的落地" class="headerlink" title="十四、技术的落地"></a>十四、技术的落地</h3><p>简单回顾下我国辽宁号航母的历史：1999年中国购买了瓦良格号，于2002年3月拖回大连港，2005年4月开始由中国海军继续建造改进，2012年9月正式更名辽宁号，交付中国人民解放军海军，2013年11月，辽宁舰从青岛远赴中国南海展开为期47天的海上综合演练，标志着辽宁号航母开始具备海上编队战斗群能力。我国前前后后花费超过10年才让辽宁号航母初步形成战力能力。</p><p>技术和武器一样，你引入一个技术是一码事，真正落地形成战斗力或者说产生业务价值完全是另外一码事。技术一般有落地周期：引入，定制改造，小规模试点，再到逐步扩大生产规模，这个周期可长可短，对于一些基础性和重量级的技术，或者涉及大规模遗留系统升级改造的技术，一般周期比较漫长（可能时间跨度长达1年甚至几年），对于这类技术的引入和落地，架构师需要高屋建瓴，通盘考虑，制定落地计划，分阶段推进技术的落地。</p><h3 id="十五、定制、自研还是购买"><a href="#十五、定制、自研还是购买" class="headerlink" title="十五、定制、自研还是购买"></a>十五、定制、自研还是购买</h3><p>这个问题比较复杂，很难一概而论，和企业的业务和团队规模，架构甚至文化等诸多因素有关系。我个人遵循的两个简单原则分别是：</p><ol><li>如果不是你最擅长，也提供不了差异化的竞争优势的技术则直接用开源或者购买。小心Not Invented Here症状，避免重复造轮子，始终牢记达成业务目标才是重点。</li><li>当企业的业务和团队规模达到一定阶段，对于处在业务关键链路上的核心技术，必须要有一定的定制甚至自研能力。创业公司尽量用开源或者购买云服务，验证业务模式是第一优先；当你的业务模式获得验证，业务和团队达到一定规模，则需逐步考虑对核心业务链路上的技术进行定制甚至自研，以获得更大的灵活性；如果你成长到接近BAT那个量级，那么大部分核心技术必然是定制甚至自研的，否则无法支撑那个规模。</li></ol><h3 id="十六、写在最后"><a href="#十六、写在最后" class="headerlink" title="十六、写在最后"></a>十六、写在最后</h3><p>本文仅限个人经验视角，技术选型理念仅供参考借鉴。每个企业的具体上下文（业务场景，团队组织，技术架构等）各不相同，每个架构师的背景经验也各不相同，大家要结合实际自己做出选型，没有最好的技术，只有相对较合适的技术。另外，好的技术选型是相互借鉴甚至PK出来的，欢迎大家讨论，给出自己的技术选型思考。</p><h3 id="十七、附录"><a href="#十七、附录" class="headerlink" title="十七、附录"></a>十七、附录</h3><ol><li><a href="https://12factor.net/" target="_blank" rel="noopener">12 Factor App</a></li><li><a href="https://www.quora.com/Is-Cassandra-to-blame-for-Digg-v4s-technical-failures" target="_blank" rel="noopener">Is Cassandra to blame for Digg v4’s technical failures?</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;技术选型是一个很热门的话题，最近我看到自己的微信朋友圈有好几篇关于技术选型的文章，读者对这类主题的热情很高。在技术组织内部，技术人员经常会面临技术选型问题，有时候，技术选型还常常牵扯好几波干系人，相互之间还会产生争议，有的甚至还可能发展到派系斗争的地步。即便像我自己，已经有十几年研发和架构经验的老司机，不管是工作还是业余，有很大部分时间的思考都是深陷在A技术和B技术的利弊权衡之中，不能自拔。无论如何，技术选型说小了关乎项目和团队成败，说大了关乎企业业务的发展，不可小觑。&lt;/p&gt;
&lt;p&gt;本文所表达的技术选型理念应该是具体技术无关的，但是由于我个人的背景更偏向互联网后端的研发和架构，所以本文的视角更偏向后端技术的选型。&lt;/p&gt;
    
    </summary>
    
      <category term="技术管理" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="技术选型" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E9%80%89%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>成长型组织如何突破技术困局</title>
    <link href="http://yoursite.com/2018/05/24/20180524/"/>
    <id>http://yoursite.com/2018/05/24/20180524/</id>
    <published>2018-05-24T03:24:02.000Z</published>
    <updated>2018-06-15T08:06:51.731Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>2017年我全程参与了一家成长型组织的技术架构转型升级，本文是在2016年底，在正式启动技术转型之前，我个人的一些战略思考总结。现在转型已经取得阶段性成果，回过头来看，对于大部分成长型组织的技术转型升级，我认为本文还是蛮有借鉴价值的。</p><p>本分享假设针对提供互联网服务的软件研发型组织，其它类似涉及IT系统的组织也可从中获得借鉴。</p><p>本分享属于个人思考心得总结，如有理解不当偏颇之处，还请大家不吝指教。</p><a id="more"></a><h3 id="一、困局"><a href="#一、困局" class="headerlink" title="一、困局"></a>一、困局</h3><p>先上三个图，分别说明企业，特别是成长型企业，所面临的普遍困局，下面是第一个：</p><p><img src="/images/20180524/square_wheel.png" alt="square wheel"></p><center style="margin: -20px 0 20px">图1 方轮子困局V1</center><p>这个图对于从大公司（如BAT）跳到初创和成长型公司的童鞋来说感触特别深刻，你跑到随便一家刚刚熬到B或C轮融资的公司，看到这里的童鞋还在用非常落后的技术（方型轮子）支持业务，童鞋们很忙很累，加班超严重，但是效率和产出很低，你忍不住搬出在大公司已经司空见惯的高端技术（圆形轮子，如云计算、容器、微服务和DevOps等一堆天花乱坠的新技术和理念），结果得到的反馈却是：“对不起，我们赶业务太忙没时间升级”，然后你就只能无语了！</p><p><img src="/images/20180524/square_wheel_v2.png" alt="square wheel v2"></p><center style="margin: -20px 0 20px">图2 方轮子困局V2</center><p>第二个图是另一个版本的方轮子困局，在大部分企业里头也是非常常见的。一方面，受到市场竞争的压力，企业中拉车一方（业务方和管理层）和推车的一方（员工），都迫于赶业务而无法停下来做系统改进提升，尽管提升的技术手段存是存在的（车里的圆形轮子）。第二种可能的情况是，企业一线的推车员工可能是意识到企业面临的效率问题的，但是企业的拉车方由于长期脱离生产一线，看不清业务支撑系统的效率问题，无法从上至下推进系统提升改进。</p><p><img src="/images/20180524/silo.png" alt="silo"></p><center style="margin: -20px 0 20px">图3 谷仓困局</center><p>第三个图称为谷仓或者烟筒（Silo）困局，反映企业内部各自为政，缺乏领导力、信任和合作所造成的困局。</p><p>上图反映一个典型的场景：</p><ol><li>业务方领导层：我们的增长太慢了，为啥我们不能比竞争对手更快推出产品？</li><li>产品管理层：我们现在不招新人了，技术团队不给力，一大堆项目堆着无法推进，研发团队是不是出了问题？</li><li>产品研发团队：没有按时交付项目不能怪我们，我们要求的机器运维一直拖着没有到位，我们的运维太挫，要换个头了。</li><li>运维团队：客户都气疯了，我们大部分时间在救火保证系统稳定性，不要再丢东西给我们了，我的团队天天熬夜都嚷嚷要离职…</li></ol><p>烟筒困局还有一个典型的问题是，企业团队倾向自立门户，重复造轮子（基础设施）、造成大量重复劳动，企业效率低下，成本骤增和浪费严重。</p><p>对谷仓困局描述最生动的要数小说《凤凰项目：一个IT运维的传奇故事》，推荐有兴趣的童鞋进一步阅读（参考附录1）。</p><h3 id="二、根因分析和破局思路"><a href="#二、根因分析和破局思路" class="headerlink" title="二、根因分析和破局思路"></a>二、根因分析和破局思路</h3><p>针对这些困局，背后的深刻原因是什么？我们该如何破局？下面是我近期的三点战略思考：</p><h4 id="1-要事第一和压强原则"><a href="#1-要事第一和压强原则" class="headerlink" title="1. 要事第一和压强原则"></a>1. 要事第一和压强原则</h4><p>Stephen R.Covey博士的《高效能人士的七个习惯》（附录2）中的第一个习惯称为要事第一，Covey还为我们提供了一个时间管理的重要工具~四象限工作法则，把事情按照重要性和紧迫性分在四个象限里头，我们的注意力应该主要放在和重要性相关的两个象限里头，</p><ul><li>A.重要但不紧迫：通常是一些基础性长期重要的事情，比如抢占市场的新产品规划，人才引进和培养，基础设施建设，系统提升型项目等</li><li>B. 既重要又紧迫：通常是一些火烧眉毛的事情，比如系统故障救火，网站紧急bug修复等</li></ul><p>这两个象限的时间分配是门平衡的艺术，理想70%的时间应该放在A象限，即未雨绸缪象限，20%的时间放在B象限，用于应急。A象限做好了，B象限事件的概率会变小。如果一个公司大部分时间在B象限救火，通常说明是A和B两个象限的时间分配失衡或者倒挂了，需要关注投资那些长期重要但不紧迫的事情。</p><p><img src="/images/20180524/priority.png" alt="priority"></p><center style="margin: -20px 0 20px">图4 四象限工作法</center><p>实力上处于劣势的企业如何与优势企业竞争？华为公司的实践表明，要实行“压强原则”，也就是将有限的资源集中于一点，在配置强度上大大超过竞争对手，以求重点突破，然后迅速扩大战果，最终达到系统领先。华为公司总裁任正非先生曾用坦克和钉子的比喻说明“压强原则”。坦克重达几十吨，却可以在沙漠中行驶，原因是宽阔的履带分散了加在单位面积上的重量；钉子质量虽小，却可以穿透硬物，是因为它将冲击力集中在小小的尖上，二者的差别就在于后者的压强更大。同样的道理应用到企业战略上，就有了“压强原则”。华为公司靠“压强原则”突破了万门数字程控交换机，突破了GSM全套移动通信设备，突破了光网络设备……几乎所有的重大产品，最初都是这么突破的。公司规模小时如此，如今公司规模大了，每年的研发费用超过了100亿元，但在项目资源配置上，还要继续贯彻“压强原则”。</p><p><img src="/images/20180524/tank.jpg" alt="tank"></p><center style="margin: -20px 0 20px">图5 坦克在沙漠中行驶自如</center><p><img src="/images/20180524/hammar.jpg" alt="hammar"></p><center style="margin: -20px 0 20px">图6 钉子击穿硬物</center><p>在《华为基本法》中是这么描述的：“在成功关键因素和选定的战略生长点上，以超过主要竞争对手的强度配置资源，要么不做，要做，就极大地集中人力、物力和财力，实现重点突破”。</p><p>抓不住重点，克制不住做新产品的冲动、妄图全面开花，常常是制造方轮子和谷仓困局的一个主要诱因。 初创或成长型公司，本身资源匮乏，研发能力相对较弱，更需贯彻“压强原则”，应抓住重点，集中资源各个击破。</p><h4 id="2-系统思考、反馈环和试错文化"><a href="#2-系统思考、反馈环和试错文化" class="headerlink" title="2. 系统思考、反馈环和试错文化"></a>2. 系统思考、反馈环和试错文化</h4><p>我们大部分人都有在高速或高架上堵车的经历，因为两辆车的事故，常常造成整个高速的流量急速下降（用我老婆的话说是龟速）甚至瘫痪，</p><p><img src="/images/20180524/bottleneck.png" alt="bottleneck"></p><center style="margin: -20px 0 20px">图7 瓶颈理论</center><p>上面这个图很形象的展示了企业管理中知名的瓶颈理论（也称约束理论），整个系统的吞吐是由系统的瓶颈决定的，例如上图，瓶颈处的容量是4，那么整个系统的吞吐量是4。在瓶颈上游的优化，上图中上游的容量是6，只会造成上游的进一步拥堵和积压，而在瓶颈下游的优化，上图中下游的容量是6，则对整个系统的吞吐没有任何帮助，反而造成资源的闲置和浪费。</p><p>IT运维管理畅销书《凤凰项目》（附录1）的作者Gene Kim在调研了众多高性能IT组织后总结了支持DevOps运作的三个原理(The Three Ways: The Principles Underpinning DevOps)（附录3），可以认为是系统改进提升的一般性原理，见下图：</p><p><img src="/images/20180524/the_three_ways.png" alt="the three ways"></p><center style="margin: -20px 0 20px">图8 支持DevOps运作的三个原理</center><p><strong>原理一：系统思考(Systems Thinking)</strong>，开发驱动的组织，其能力不是制作软件，而是持续的交付客户价值。价值从业务需求开始，经过研发测试，到部署运维，依次流动，并最终以服务形式交付到客户手中。整个价值流速并不依赖单个部门（团队或个人）的杰出工作，而是受整个价值链最薄弱环节（瓶颈）的限制，所以局部优化通常是无效的，反而常常导致全局受损。</p><p>Gene Kim特别指出，</p><blockquote><p>在瓶颈之外的任何优化提升都只是幻象。<br>Any improvements made anywhere besides the bottleneck are an illusion.<br>— Gene Kim</p></blockquote><p>在研发型组织中，常见的系统瓶颈如运维机器资源提供（Provisioning）缓慢，发布流程繁琐容易出错，遗留系统耦合历史负担重，研发基础平台和框架薄弱等等。这些瓶颈点是研发型组织特别需要关注和优化的。</p><p><strong>原理二：强化反馈环(Amplify Feedback Loops)</strong>，过程改进常常通过缩短和加强反馈环来达成，原理二强调强化企业和客户之间，企业组织团队间，流程上和系统内的反馈环（如图9）。没有测量就没有提升（图10），反馈要以测量和数据作为基础，通过反馈数据来优化和改进系统。强化反馈环在技术上的一些主要手段包括大数据分析和监控告警等。</p><p><img src="/images/20180524/feedback_loop.png" alt="feedback loop"></p><center style="margin: -20px 0 20px">图9 强化反馈环</center><p><img src="/images/20180524/measure.png" alt="measure and improve"></p><center style="margin: -20px 0 20px">图10 没有测量就没有提升</center><p><strong>原理三：持续试验和学习的文化(Culture of Continual Experimentation And Learning)</strong>，在企业管理文化层面强调勇于试错和持续试验的文化，真正的试错文化包括：</p><ol><li>管理层要承认企业内部50%的创新或流程提升项目是可能失败的，即使失败，员工不会受到责罚，鼓励持续的实验和从中学习。</li><li>管理层要有技术偿债意识，勿追求100%的员工利用率，要留至少20%~30%的时间给员工做创新和系统改进提升项目。</li></ol><p>技术研发型组织，尤其是领导层，视野不足仅仅关注自己的一亩三分地（局部优化），缺乏全局系统思考和合作意识薄弱，常常是造成组织各自为政的谷仓困局的另一个主要诱因。而企业和客户之间，企业组织团队间，流程上和系统内的反馈环不闭合，则会让谷仓和方轮子困局进一步恶化。企业追求追责文化，则会造成员工束手不敢试错，出了问题则相互推诿和扯皮。企业追求100%的员工利用率，过分“压榨”员工，没有技术债偿还意识，不懂得留至少20%~30%的系统提升改进时间，光顾要母鸡生蛋但对母鸡本身照顾不到位，必然导致方轮子困局。</p><h4 id="3-提升人才密度"><a href="#3-提升人才密度" class="headerlink" title="3. 提升人才密度"></a>3. 提升人才密度</h4><p>我个人认为，造成方轮子和谷仓困局的根本性问题还是企业的人才密度不够，无法支撑起日益复杂的业务和系统。不管是领导力、信任和协作、规划和抓工作重点能力，还是系统思考、闭环反馈和试错文化、都离不开人才密度这个根基的支撑。初创型公司，一开始的目标是找准市场和谋活，一般花不起钱和很难找到好的开发人员，当然一开始的业务不复杂，一般的开发人员可以应付。随着业务复杂度的增加，一般开发人员难免堆砌业务代码和欠下大量的技术债务（坑），当企业的业务和系统复杂度到一个点，方形轮子和谷仓困局就出现了（如图11）。</p><p><img src="/images/20180524/talent_density.png" alt="talent density"></p><center style="margin: -20px 0 20px">图11 人才密度和业务复杂度的关系</center><p>互联网研发是一个智力密集型行业，一个好的研发人员和一个普通的研发人员到底有多大差异？我看到过至少三个版本：</p><ol><li>第一个版本是Steve McConnell在《代码大全》（附录4）一书中提到的：“A good programmer can be as 10x times more productive than a mediocre one”，优秀程序员生产力可以是一般程序员生产力的10倍。</li><li>第二版本来自被誉为硅谷最重要的文档《Netflix企业文化》ppt（附录5）：对于程序性工作，顶级员工的输出量是一般员工的2倍，对于创新和创意型的工作，顶级员工的输出是一般员工的10倍。</li><li>第三个版本是乔布斯讲的：在软件行业里，最好的人才与一般的人才的差距是50倍，甚至是100倍！</li></ol><p>不管这些数字是否准确，足以说明说明业界大牛和伟大公司对人才密度的重视。随着业务和系统复杂度的增加，如果企业人才密度跟不上，必然造成方型轮子和谷仓困局。所以应对上述企业困局的根本性方法，还是要想办法提升人才密度，说白了就是要换血，用海尔张瑞敏的话说就是要引入“负熵”。创业或成长型公司到一定阶段如果有钱了，老板千万记得花钱提升人才密度，特别要舍得花钱引进行业大牛。</p><p>另外还要注意那些表面看起来常常身处救火一线，常常加班熬夜的所谓“猛将明星”型员工，他们有可能恰恰是埋了很多坑的问题制造者，因为在软件行业，真正好的研发人员其实是非常“懒惰”的，他们大部分时间在思考和设计（好像不在做事），换句话说他们大部分时间花在未雨绸缪的A象限，做事的时候也常常尽可能采用自动化的手段，对于技术方案，他们会权衡长期的可维护性和可规模化，知道有些技术方案虽然可行，但是长期不可维护和规模化，所以不能这样干。找到这样的员工是企业之福。</p><h3 id="三、总结"><a href="#三、总结" class="headerlink" title="三、总结"></a>三、总结</h3><p>下面总结突破方轮子和谷仓困局的五点思路：</p><ol><li>不惜代价引进优秀人才，特别是行业大牛，提升企业人才密度，人才密度要领先于业务复杂度。</li><li>要事优先，总结并抓住系统改进提升的重点环节并立项，贯彻“压强原则”，确保重点系统改进型项目的长期坚持推进和落地。</li><li>培养企业员工特别是领导层的流式(flow)思维、系统性思维和加强合作意识，协同找出系统瓶颈，针对瓶颈立项，集中投入资源做改进和提升。</li><li>培养企业员工的闭环反馈意识，建立和强化业务、团队沟通、流程和系统各个层次的反馈环。建设监控和数据分析基础设施，基于数据和可视化反馈改进和完善系统。</li><li>鼓励试错和免责文化，支持业务的同时留20%~30%时间给员工做系统提升和改进。</li></ol><p>上面分析了方轮子和谷仓困局背后的深层次原因和一般性的解决思路，那么我们该如何落地提升呢？如下图，对一个处在方轮子困局阶段的企业，如何达到BAT水平呢？一蹴而就直线到达显然是不现实的。</p><p><img src="/images/20180524/linear.png" alt="linear"></p><center style="margin: -20px 0 20px">图12 直线式转型</center><p><img src="/images/20180524/incremental.png" alt="incremental"></p><center style="margin: -20px 0 20px">图13 曲线式转型</center><p>图13反映企业改进转型的现实情况，员工一般会经历从害怕，到恐慌，到放弃，到逐步接受并到达终点，中间还会经历反复，可能还会退回到老习惯做事的方法，但只要坚持推进，最终会达到终点。</p><p><img src="/images/20180524/continous_improvement.png" alt="continous improvement"></p><center style="margin: -20px 0 20px">图14 持续提升</center><p>一蹴而就(Big Bang)式的提升转型非常困难，一方面员工通常反弹会很大，另一方面太过折腾甚至可能影响到企业业务的健康发展。所以一般提升需要分解为各个阶段，每个阶段制定重点转型提升任务目标，借助如PDSA（Plan-Do-Study-Act）等闭环式管理工具，稳步长期锲而不舍推进，直至达成目标。</p><h3 id="附录"><a href="#附录" class="headerlink" title="附录"></a>附录</h3><ol><li><a href="https://book.douban.com/subject/26644070/" target="_blank" rel="noopener">凤凰项目：一个IT运维的传奇故事</a></li><li><a href="https://book.douban.com/subject/1048007/" target="_blank" rel="noopener">高效能人士的七个习惯</a></li><li><a href="http://itrevolution.com/the-three-ways-principles-underpinning-devops/" target="_blank" rel="noopener">支持DevOps运作的三个原理</a></li><li><a href="https://book.douban.com/subject/1477390/" target="_blank" rel="noopener">代码大全第2版</a></li><li><a href="http://wenku.baidu.com/view/ef9319b4ad51f01dc381f166.html" target="_blank" rel="noopener">Netflix企业文化ppt</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;2017年我全程参与了一家成长型组织的技术架构转型升级，本文是在2016年底，在正式启动技术转型之前，我个人的一些战略思考总结。现在转型已经取得阶段性成果，回过头来看，对于大部分成长型组织的技术转型升级，我认为本文还是蛮有借鉴价值的。&lt;/p&gt;
&lt;p&gt;本分享假设针对提供互联网服务的软件研发型组织，其它类似涉及IT系统的组织也可从中获得借鉴。&lt;/p&gt;
&lt;p&gt;本分享属于个人思考心得总结，如有理解不当偏颇之处，还请大家不吝指教。&lt;/p&gt;
    
    </summary>
    
      <category term="技术管理" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="技术转型" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF%E8%BD%AC%E5%9E%8B/"/>
    
  </entry>
  
  <entry>
    <title>聊聊Netflix技术那些大胆的创新</title>
    <link href="http://yoursite.com/2018/05/23/20180523/"/>
    <id>http://yoursite.com/2018/05/23/20180523/</id>
    <published>2018-05-23T13:01:29.000Z</published>
    <updated>2018-06-15T11:49:52.286Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>昨天晚上和下属一起吃晚饭，期间聊到Netflix技术那些大胆的创新，事后觉得有必要总结一下，给团队分享，让大家了解世界顶级的技术组织在技术、架构、组织和文化方面的创新。让大家在埋头干活的时候，偶尔也可以抬头看看天（大处着眼，小处着手）。于是就有了这篇文章。</p><p>注意，Netflix技术本身也在快速的迭代进化中，本文主要基于Netflix在slideshare上的分享总结而成，其中的很多内容目前可能已经过时，但是Netflix的创新文化和精神仍然值得我们学习借鉴。</p><a id="more"></a><h3 id="一、大规模生产级微服务架构实践"><a href="#一、大规模生产级微服务架构实践" class="headerlink" title="一、大规模生产级微服务架构实践"></a>一、大规模生产级微服务架构实践</h3><p>微服务很多公司(eBay, Amazon, BAT)都有，甚至比Netflix做得更早，但Netflix大概是大规模生产级微服务做得最杰出的。</p><p>100s范围的微服务，1000s范围的每日生产变更，10,000s范围的实例，1,000,000s范围的活跃客户数，1,000,000,000s范围的度量。但是只有10s范围的运维工程师，没有自己的数据中心NOC，应该算微服务DevOps的最高境界了。</p><p><img src="/images/20180523/netflix_ecosystem.jpg" alt="netflix ecosystem"></p><p><img src="/images/20180523/no_noc.jpg" alt="no noc"></p><p><img src="/images/20180523/msa_visualization.jpg" alt="msa visualization"><br>Netflix微服务可视化。</p><h3 id="二、开源整个微服务技术栈"><a href="#二、开源整个微服务技术栈" class="headerlink" title="二、开源整个微服务技术栈"></a>二、开源整个微服务技术栈</h3><p>Netflix微服务技术栈的核心组件基本上都是开源的。Pivotal在2~3年前把Netflix开源的这摊东西封装一下改头换面，再拼凑一些其它东西（配置中心，调用链监控等）就变成了Spring Cloud。现在大家耳熟能详的Zuul网关，Eureka服务发现注册中心，Hystrix熔断限流，Archaius配置等组件，Netflix在2012年左右就都开源出来了。</p><p><img src="/images/20180523/oss_strategy.png" alt="oss strategy"><br>开放开源是Netflix的一种竞争战略。</p><p><img src="/images/20180523/oss_goal.jpg" alt="oss goal"></p><p>Netflix为啥热衷于要搞开源？</p><ol><li>将自己的解决方案建立为行业标准和最佳实践</li><li>建立Netflix技术品牌</li><li>雇佣、留住和吸引顶级工程师</li><li>从共享生态中获得反馈输入并受益</li></ol><h3 id="三、系统全部迁移AWS公有云"><a href="#三、系统全部迁移AWS公有云" class="headerlink" title="三、系统全部迁移AWS公有云"></a>三、系统全部迁移AWS公有云</h3><p>大致在09/10年左右， Netflix就开始启动上公有云战略（当然背后也是吃了自建数据中心的苦头），应用逐步向AWS迁移，这个过程一共持续了将近5年，到15年的时候，迁移完毕，全部应用上到AWS。09/10年左右的AWS还不太成熟，别说当时，即使现在也没有几个大公司不掂量一下敢提全部迁移公有云的战略。另外AWS能有今天，Netflix也是功不可没，帮Amazon躺了无数的坑。</p><p><img src="/images/20180523/migrate_to_aws.jpg" alt="migrate to aws"></p><h3 id="四、在AWS基础上打造PaaS平台"><a href="#四、在AWS基础上打造PaaS平台" class="headerlink" title="四、在AWS基础上打造PaaS平台"></a>四、在AWS基础上打造PaaS平台</h3><p>Netflix在AWS IAAS的基础上封装打造了自己的PaaS云平台服务(大部分组件开源)，包括</p><ol><li>平台运行时服务(Eureka，Zuul, Edda，Atlas)</li><li>平台库和框架(Karyon/Ribbon，Hystrix，RxJava, Governator，Servo, Archaius, Astyanax)</li><li>平台大数据和缓存服务(Cassandra/ES/Hadoop Platform as a Service, EVCache，S3)</li><li>平台工具和服务(Asgard/Aminator， SimianArmy/ChaosMonkey, ICE)</li></ol><p><img src="/images/20180523/netflix_cloud_stack.png" alt="netflix cloud stack"></p><p><img src="/images/20180523/deployment_arch.png" alt="deployment arch"></p><p>业内最近开始提出云原生(Cloud Native)架构的理念，Pivotal是这个理念的主要推动者（背后主要是要推它的Cloud Foundry产品）。其实Netflix在2013年就提出了Cloud Native理念，而且它的整个平台(AWS IAAS + PaaS)就是云原生的。</p><h3 id="五、两地三中心高可用"><a href="#五、两地三中心高可用" class="headerlink" title="五、两地三中心高可用"></a>五、两地三中心高可用</h3><p>Netflix的高可用架构也是做得大气磅礴，同城部署3个对等的可用区(AWS Availability Zone)，1个甚至2个挂不影响可用性。</p><p><img src="/images/20180523/zone.png" alt="zone"></p><p>异地(Regions)再做对等部署，一个Region里头的AZ全挂，另外一个Region接着可用。</p><p><img src="/images/20180523/region.png" alt="region"></p><h3 id="六、采用Cassandra-NoSql作为主数据库"><a href="#六、采用Cassandra-NoSql作为主数据库" class="headerlink" title="六、采用Cassandra NoSql作为主数据库"></a>六、采用Cassandra NoSql作为主数据库</h3><p>Netflix原来用Oracle等传统Sql数据库，但是受到扩展性挑战。公司架构管理层大胆颠覆性提出使用Cassandra Nosql作为主要的持久化化存储机制，Netflix在2012年就做到大部分数据存放Cassandra和S3等非关系数据库上。这个架构决策也是非常大胆有魄力，一般没有几个公司敢这么干的。Cassandra本质上是一种KV数据库，更像sorted map存储，不支持事务，不支持join。在CAP理论中，Cassandra是展现AP特性，无中心分散式高可用，天然支持跨数据中心数据同步，这大概是Netflix最看重的特性。Cassandra是读慢写快的特性（一般数据库是读快写慢）,Netflix大量使用Memcached做缓存补偿。</p><p><img src="/images/20180523/cassandra.png" alt="cassandra"></p><p>Cassandra在同城多个Zone之间同步数据，在异地(Inter-Region)之间再同步，流量到9Gbits/s，延迟83ms，18TB的数据备份(2013年的数据)。</p><h3 id="七、镜像部署和发布自动刹车"><a href="#七、镜像部署和发布自动刹车" class="headerlink" title="七、镜像部署和发布自动刹车"></a>七、镜像部署和发布自动刹车</h3><p>近年docker容器技术大火，大家都在谈不可变基础设施(immutable infrastructure)的理念，本质就是镜像部署。Netflix在2012年前就已经实现镜像部署，发布的单位是AMI(Amazon Machine Image)镜像，通过持续交付工具Asgard（现在升级版叫Spinnaker）直接将镜像推到AWS云中部署，支持蓝绿（需要至少两倍虚机），灰度和金丝雀等部署模式。</p><p><img src="/images/20180523/paved_road.png" alt="paved road"></p><p>Netflix的发布管道叫Paved Road，就是平台团队铺好的路，由提交，构建，AMI镜像烘焙(Image Baking)和发布四个阶段组成。</p><p>金丝雀发布之后，系统会自动生成金丝雀健康报告和分数（背后需要统计上千个metrics + 复杂智能算法），达到一定的分数(比如80分)，才能继续roll out。这个也称发布自动刹车。</p><p><img src="/images/20180523/canary_score.png" alt="canary score"></p><p><img src="/images/20180523/canary_score2.png" alt="canary score 2"></p><h3 id="八、反脆弱架构"><a href="#八、反脆弱架构" class="headerlink" title="八、反脆弱架构"></a>八、反脆弱架构</h3><p>Netflix大胆提出反脆弱架构的理念（架构师受到尼古拉斯·塔勒布《反脆弱》一书的启发，并将其应用到架构领域）：为了让你的系统更加健壮，不是将它们严格保护起来，而是主动随机性地的增加一些破坏性测试，逼迫研发人员做好高可用。</p><p><img src="/images/20180523/chaos_monkey.jpg" alt="chaos monkey"></p><p>Netflix从周一至周五，上午9点到下午3点，混乱猴子军团会随机杀生产实例，这个叫Chaos Monkey，还有增加延迟的Latency Monkey。</p><p><img src="/images/20180523/more_monkey.png" alt="more monkey"></p><p>还有Chaos Gorilla可以杀整个可用区(Availability Zone)，Chaos Kong杀整个Region。据说Netflix曾主动关闭一个可用区，客户没有任何影响。</p><p>国内一些互联网公司也有演习和自攻一说，但基本都是提前打招呼的，规模一般也不大，Netflix是随机不打招呼玩真的。</p><h3 id="九、几乎没有流程，没有员工手册"><a href="#九、几乎没有流程，没有员工手册" class="headerlink" title="九、几乎没有流程，没有员工手册"></a>九、几乎没有流程，没有员工手册</h3><p>Netflix是一家高度重视人才密度，重自由和责任文化，轻流程的公司。公司没有正式的员工手册，只有一条简单的指导原则：</p><p>Act in Netflix’s best interest，以Netflix的最佳利益行事。</p><p><img src="/images/20180523/culture.png" alt="culture"></p><h3 id="十、No-CTO-No-Ops"><a href="#十、No-CTO-No-Ops" class="headerlink" title="十、No CTO, No Ops"></a>十、No CTO, No Ops</h3><p>Netflix的技术这么牛逼，但它是没有技术CTO职位的，只有首席产品CPO，工程团队和产品团队的VP都向CPO汇报。这样做更多是为了产品导向，便于技术和产品沟通合作，避免两边扯，避免业务驱动还是技术驱动的悖论，大家都是产品驱动。Netflix把它称为BusDevOps组织架构。</p><p><img src="/images/20180523/org_arch.jpg" alt="organization architecture"></p><p>Netflix也没有独立的运维团队(NoOps)，架构+中间件+运维+大数据闭环统称为云平台工程(Cloud and Platform Engineering)团队，一个VP总负责，更好地对接DevOps文化。Netflix的产品导向文化非常浓厚，连平台工程团队开源出来的产品都是整整齐齐的(见<a href="https://netflix.github.io/)，PaaS云平台是整个云平台工程团队最大的产品输出。" target="_blank" rel="noopener">https://netflix.github.io/)，PaaS云平台是整个云平台工程团队最大的产品输出。</a></p><p><img src="/images/20180523/tech_org.png" alt="technical organization"></p><p>Netflix的CTO其实是Chief Talent Officer，负责人才招聘的，公司对人才的重视可见一斑。</p><p><img src="/images/20180523/cto.png" alt="cto"></p><h3 id="十一、无论公司兴衰，始终支付市场最高工资"><a href="#十一、无论公司兴衰，始终支付市场最高工资" class="headerlink" title="十一、无论公司兴衰，始终支付市场最高工资"></a>十一、无论公司兴衰，始终支付市场最高工资</h3><p>不用多解释，这大概是Netflix最有霸气底气和牛逼的一点。据我在米国的同学讲，去Netflix基本是硅谷顶薪，博士毕业去给开了超过30万美金的年薪（这还是前几年的行情）。一般进去难，去了留下来也不容易，不胜任的被客客气气劝退的有。能留下来的一般也不跳，因为再跳也没有更高的待遇了。</p><p><img src="/images/20180523/top_pay.png" alt="top pay"></p><p>显然，没有顶级的人才密度，就无法支撑其高大上的技术架构和鹤立鸡群的文化。顶级的人才聚集在一起，容易碰撞迸发创新火花，捣腾出颠覆性的东西和理念。</p><h3 id="写在最后"><a href="#写在最后" class="headerlink" title="写在最后"></a>写在最后</h3><p>我在这边总结Netflix技术做的牛逼的事情，一方面是因为钦佩，但这不是重点，毕竟目前国内基础环境和人才密度是支撑不起这种类型文化的公司；但是，他山之石，可以攻玉，Netflix的很多技术、架构、组织和文化思路值得我们学习和借鉴。</p><p>我本人没有在Netflix工作过，上面的信息主要通过互联网共享资料(特别是slideshare)学习解读(有些解读可能还是偏颇的)，所谓强者无秘密，Netflix的强大也体现在它无私分享精神，它在公司内部是信息公开透明分享的，对外部也一样，几乎所有Netflix微服务技术栈(也称NetflixOSS)你可以从github.com/netflix免费获得，其内部架构和技术相关资料基本上都可以通过slideshare或者Netflix techblog免费获得。在公开透明一块即使Google、Amazon和Apple这些互联网巨头都应该是自叹不如的。Netflix公司大概是地球上开出的一朵特别奇葩耀眼的花。</p><p>向Netflix致敬!</p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;昨天晚上和下属一起吃晚饭，期间聊到Netflix技术那些大胆的创新，事后觉得有必要总结一下，给团队分享，让大家了解世界顶级的技术组织在技术、架构、组织和文化方面的创新。让大家在埋头干活的时候，偶尔也可以抬头看看天（大处着眼，小处着手）。于是就有了这篇文章。&lt;/p&gt;
&lt;p&gt;注意，Netflix技术本身也在快速的迭代进化中，本文主要基于Netflix在slideshare上的分享总结而成，其中的很多内容目前可能已经过时，但是Netflix的创新文化和精神仍然值得我们学习借鉴。&lt;/p&gt;
    
    </summary>
    
      <category term="技术管理" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="Netflix" scheme="http://yoursite.com/tags/Netflix/"/>
    
  </entry>
  
  <entry>
    <title>架构师必须知道的架构设计原则</title>
    <link href="http://yoursite.com/2018/05/21/20180521/"/>
    <id>http://yoursite.com/2018/05/21/20180521/</id>
    <published>2018-05-21T06:30:56.000Z</published>
    <updated>2018-06-15T08:07:44.931Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>如果一个技术已经存在3年，比如现在很火的前端技术react和vue等，那么我能预估这个技术大致还有3年的生命期，再久就不确定了；如果一个架构或设计原则已经存在15年，例如单一职责和依赖倒置原则，我可以预期它还有15年甚至更久的生命期。原则是比具体技术更抽象，更接近事物本质，也更经得起时间考验的东西。这些原则沉淀在架构师的脑海中，最终内化成他的mindset，以潜意识方式影响和指导他的架构和设计工作。</p><p>一晃我在软件研发行业工作十多个年头了，前面大部分时间做架构设计和开发，现在转型做研发管理。随着时间的推移，很多技战术细节性的东西(工具，框架，编程语言)在我脑海中渐渐模糊，但是一些平时学习积累起来，并且在实践中加深体会的软件架构设计和组织原则，这些原则性的东西却丝毫没有被时间冲淡，反而愈加清新。现在即使我不在一线开发，但这些沉淀下来的原则仍然潜移默化地影响我的日常管理和部分架构设计指导工作。我想有必要总结一下那些业界知名，给我留下深刻印象的软件架构设计和组织原则，和大家一起分享。</p><a id="more"></a><h3 id="一、软件设计原则"><a href="#一、软件设计原则" class="headerlink" title="一、软件设计原则"></a>一、软件设计原则</h3><h4 id="GRASP通用职责分配软件模式"><a href="#GRASP通用职责分配软件模式" class="headerlink" title="GRASP通用职责分配软件模式"></a>GRASP通用职责分配软件模式</h4><p>来自Craig Larman的软件设计书《UML和模式应用》[附录1]，Larman在书中提出软件设计的关键任务是职责分配，并提炼总结出9种(5种核心+4种扩展)软件职责分配模式，这些模式是比GoF设计模式更抽象的元模式。</p><h5 id="1-信息专家-Information-Expert"><a href="#1-信息专家-Information-Expert" class="headerlink" title="1. 信息专家(Information Expert)"></a>1. 信息专家(Information Expert)</h5><p>为对象分配职责的通用原则 – 把职责分配给拥有足够信息可以履行职责的专家</p><h5 id="2-创建者-Creator"><a href="#2-创建者-Creator" class="headerlink" title="2. 创建者(Creator)"></a>2. 创建者(Creator)</h5><p>将创建A的职责赋给B，如果至少下面一种情况为真：</p><ul><li>B“包含”或者聚合A</li><li>B记录A的实例</li><li>B密切地使用A</li><li>B拥有A的初始化数据</li></ul><h5 id="3-低耦合-Low-Coupling"><a href="#3-低耦合-Low-Coupling" class="headerlink" title="3. 低耦合(Low Coupling)"></a>3. 低耦合(Low Coupling)</h5><p>赋予职责使得对象间的耦合度尽可能低，最小化对象间的依赖和变更影响，最大化重用。</p><h5 id="4-高内聚-High-Cohesion"><a href="#4-高内聚-High-Cohesion" class="headerlink" title="4. 高内聚(High Cohesion)"></a>4. 高内聚(High Cohesion)</h5><p>赋予职责使得每个对象的职责尽可能保持聚焦和单一，易于管理和理解。</p><h5 id="5-控制器-Controller"><a href="#5-控制器-Controller" class="headerlink" title="5.控制器(Controller)"></a>5.控制器(Controller)</h5><p>把职责赋予系统、设备或者子系统的表示类(门面控制器)，或者某个用例的表示类(用例控制器)，让控制器接收事件并协调整个系统的运作。</p><h5 id="6-多态-Polymorphism"><a href="#6-多态-Polymorphism" class="headerlink" title="6. 多态(Polymorphism)"></a>6. 多态(Polymorphism)</h5><p>将职责分配给多个具有同名方法的多态子类，运行时根据需要动态切换子类，让系统行为变得可插拔。</p><h5 id="7-纯虚构-Pure-Fabrication"><a href="#7-纯虚构-Pure-Fabrication" class="headerlink" title="7. 纯虚构(Pure Fabrication)"></a>7. 纯虚构(Pure Fabrication)</h5><p>针对真实问题域中不存在，但是设计建模中有用的概念，设计虚构类并赋予职责。</p><h5 id="8-间接-Indirection"><a href="#8-间接-Indirection" class="headerlink" title="8. 间接(Indirection)"></a>8. 间接(Indirection)</h5><p>在两个或者多个对象间有交互的情况下，为避免直接耦合，提高重用性，创建中间类并赋予职责，对象的交互交由中间类协调。</p><h5 id="9-受保护的变化-Protected-Variation"><a href="#9-受保护的变化-Protected-Variation" class="headerlink" title="9. 受保护的变化(Protected Variation)"></a>9. 受保护的变化(Protected Variation)</h5><p>简单讲就是封装变化。识别系统中可能的不稳定或者变化，在不稳定组件上创建稳定的抽象接口，将可能的变化封装在接口之后，使得系统内部的不稳定或者变化不会对系统的其它部分产生不良影响。</p><h4 id="SOLID面向对象设计原则"><a href="#SOLID面向对象设计原则" class="headerlink" title="SOLID面向对象设计原则"></a>SOLID面向对象设计原则</h4><h5 id="1-单一职责原则-The-Single-Responsibility-Principle"><a href="#1-单一职责原则-The-Single-Responsibility-Principle" class="headerlink" title="1. 单一职责原则(The Single Responsibility Principle)"></a>1. 单一职责原则(The Single Responsibility Principle)</h5><p>修改某个类的理由应该只有一个，如果超过一个，说明类承担不止一个职责，要视情况拆分。</p><p><img src="/images/20180521/srp.png" alt="srp"></p><h5 id="2-开放封闭原则-The-Open-Closed-Principle"><a href="#2-开放封闭原则-The-Open-Closed-Principle" class="headerlink" title="2. 开放封闭原则(The Open Closed Principle)"></a>2. 开放封闭原则(The Open Closed Principle)</h5><p>软件实体应该对扩展开放，对修改封闭。一般不要直接修改类库源码（即使你有源代码），通过继承等方式扩展。</p><p><img src="/images/20180521/ocp.png" alt="ocp"></p><h5 id="3-里氏替代原则-The-Liskov-Substitution-Principle"><a href="#3-里氏替代原则-The-Liskov-Substitution-Principle" class="headerlink" title="3. 里氏替代原则(The Liskov Substitution Principle)"></a>3. 里氏替代原则(The Liskov Substitution Principle)</h5><p>当一个子类的实例能够被替换成任何超类的实例时，它们之间才是真正的is-a关系。</p><p><img src="/images/20180521/lsp.png" alt="lsp"></p><h5 id="4-依赖倒置原则-The-Dependency-Inversion-Principle"><a href="#4-依赖倒置原则-The-Dependency-Inversion-Principle" class="headerlink" title="4. 依赖倒置原则(The Dependency Inversion Principle)"></a>4. 依赖倒置原则(The Dependency Inversion Principle)</h5><p>高层模块不应该依赖于底层模块，二者都应该依赖于抽象。换句话说，依赖于抽象，不要依赖于具体实现。比方说，你不会把电器电源线焊死在室内电源接口处，而是用标准的插头插在标准的插座(抽象)上。</p><p><img src="/images/20180521/dip.png" alt="dip"></p><h5 id="5-接口分离原则-The-Interface-Segregation-Principle"><a href="#5-接口分离原则-The-Interface-Segregation-Principle" class="headerlink" title="5. 接口分离原则(The Interface Segregation Principle)"></a>5. 接口分离原则(The Interface Segregation Principle)</h5><p>不要强迫用户去依赖它们不使用的接口。换句话说，使用多个专门的接口比使用单一的大而全接口要好。</p><p><img src="/images/20180521/isp.png" alt="isp"></p><h4 id="我的解读"><a href="#我的解读" class="headerlink" title="我的解读"></a>我的解读</h4><ol><li>我职业早年主要关注软件设计和编程，所以花蛮多时间学习和消化GRASP和SOLID设计原则。这些原则对我影响很深，尤其是单一职责，信息专家，关注分离，依赖倒置/封装变化，分而治之等核心原则，现在日常研发中我时常用这些原则指导新手工程师。</li><li><strong>高内聚+低耦合</strong>，就像道中的一阴一阳，是所有其它OO设计原则的原则(元原则)，其它设计原则都是在这两个基础上泛化衍生出来的。</li><li>上述原则虽然是针对OO设计和编程提出，但是对于大规模系统架构仍然适用。比如，微服务架构就体现了：<ul><li>单一职责：一个微服务尽可能要职责单一，提供的接口也尽可能单一(接口分离原则)，安全/路由/限流等跨横切面的关注点(Cross-Cutting Concerns)由独立网关负责，体现关注分离(Separation of Concerns)。</li><li>信息专家：当不确定哪个团队应该负责某个微服务时，一般原则也是谁拥有数据谁负责，基于有界上下文Bounded Context（一般是边界比较清晰的领域数据源）构建微服务。</li><li>松散耦合：服务之间通过HTTP/JSON等轻量机制通信，服务之间不强耦合。</li><li>受保护的变化和依赖倒置：服务之间只依赖抽象接口，实现可能随时变化。</li><li>间接：网关在外面的客户端和内部的服务之间增加了一层间接，使两者不强耦合，可以相互独立演化。</li></ul></li><li>作为架构师或者设计师，有两个设计能力是需要重点培养的，也是最难和最能体现架构设计水平的：<ul><li><strong>合理的职责分配能力</strong>，也就是每个类/组件/子系统应该承担什么职责，如何保证职责单一，它们之间如何协作；</li><li><strong>系统抽象和核心领域建模能力</strong>，需要深入一线业务域。</li></ul></li></ol><h3 id="二、分布式系统架构设计原则和理论"><a href="#二、分布式系统架构设计原则和理论" class="headerlink" title="二、分布式系统架构设计原则和理论"></a>二、分布式系统架构设计原则和理论</h3><h4 id="AKF架构原则"><a href="#AKF架构原则" class="headerlink" title="AKF架构原则"></a>AKF架构原则</h4><p>这15个架构原则来自《架构即未来(The Art of Scalability)》[附录2]一书，作者马丁L.阿伯特和迈克尔T.费舍尔分别是eBay和PayPal的前CTO，他们经历过eBay和PayPal大规模分布式电商平台的架构演进，在一线实战经验的基础上总结并提炼出15条架构原则：</p><h5 id="1-N-1设计"><a href="#1-N-1设计" class="headerlink" title="1. N + 1设计"></a>1. N + 1设计</h5><p>永远不要少于两个，通常为三个。比方说无状态的Web/API一般部署至少&gt;=2个。</p><h5 id="2-回滚设计"><a href="#2-回滚设计" class="headerlink" title="2. 回滚设计"></a>2. 回滚设计</h5><p>确保系统可以回滚到以前发布过的任何版本。可以通过发布系统保留历史版本，或者代码中引入动态开关切换机制(Feature Switch)。</p><h5 id="3-禁用设计"><a href="#3-禁用设计" class="headerlink" title="3. 禁用设计"></a>3. 禁用设计</h5><p>能够关闭任何发布的功能。新功能隐藏在动态开关机制(Feature Switch)后面，可以按需一键打开，如发现问题随时关闭禁用。</p><h5 id="4-监控设计"><a href="#4-监控设计" class="headerlink" title="4. 监控设计"></a>4. 监控设计</h5><p>在设计阶段就必须考虑监控，而不是在实施完毕之后补充。例如在需求阶段就要考虑关键指标监控项，这就是度量驱动开发(Metrics Driven Development)的理念。</p><h5 id="5-设计多活数据中心"><a href="#5-设计多活数据中心" class="headerlink" title="5. 设计多活数据中心"></a>5. 设计多活数据中心</h5><p>不要被一个数据中心的解决方案把自己限制住。当然也要考虑成本和公司规模发展阶段。</p><h5 id="6-使用成熟的技术"><a href="#6-使用成熟的技术" class="headerlink" title="6. 使用成熟的技术"></a>6. 使用成熟的技术</h5><p>只用确实好用的技术。商业组织毕竟不是研究机构，技术要落地实用，成熟的技术一般坑都被踩平了，新技术在完全成熟前一般需要踩坑躺坑。</p><h5 id="7-异步设计"><a href="#7-异步设计" class="headerlink" title="7. 异步设计"></a>7. 异步设计</h5><p>能异步尽量用异步，只有当绝对必要或者无法异步时，才使用同步调用。</p><h5 id="8-无状态系统"><a href="#8-无状态系统" class="headerlink" title="8. 无状态系统"></a>8. 无状态系统</h5><p>尽可能无状态，只有当业务确实需要，才使用状态。无状态系统易于扩展，有状态系统不易扩展且状态复杂时更易出错。</p><h5 id="9-水平扩展而非垂直升级"><a href="#9-水平扩展而非垂直升级" class="headerlink" title="9. 水平扩展而非垂直升级"></a>9. 水平扩展而非垂直升级</h5><p>永远不要依赖更大、更快的系统。一般公司成长到一定阶段普遍经历过买更大、更快系统的阶段，即使淘宝当年也买小型机扛流量，后来扛不住才体会这样做不scalable，所以才有后来的去IOE行动。</p><h5 id="10-设计时至少要有两步前瞻性"><a href="#10-设计时至少要有两步前瞻性" class="headerlink" title="10. 设计时至少要有两步前瞻性"></a>10. 设计时至少要有两步前瞻性</h5><p>在扩展性问题发生前考虑好下一步的行动计划。架构师的价值就体现在这里，架构设计对于流量的增长要有提前量。</p><h5 id="11-非核心则购买"><a href="#11-非核心则购买" class="headerlink" title="11. 非核心则购买"></a>11. 非核心则购买</h5><p>如果不是你最擅长，也提供不了差异化的竞争优势则直接购买。避免Not Invented Here症状，避免凡事都要重造轮子，毕竟达成业务目标才是重点。</p><h5 id="12-使用商品化硬件"><a href="#12-使用商品化硬件" class="headerlink" title="12. 使用商品化硬件"></a>12. 使用商品化硬件</h5><p>在大多数情况下，便宜的就是最好的。这点和第9点是一致的，通过商品化硬件水平扩展，而不是买更大、更快的系统。</p><h5 id="13-小构建、小发布和快试错"><a href="#13-小构建、小发布和快试错" class="headerlink" title="13. 小构建、小发布和快试错"></a>13. 小构建、小发布和快试错</h5><p>全部研发要小构建，不断迭代，让系统不断成长。这个和微服务理念一致。</p><h5 id="14-隔离故障"><a href="#14-隔离故障" class="headerlink" title="14. 隔离故障"></a>14. 隔离故障</h5><p>实现故障隔离设计，通过断路保护避免故障传播和交叉影响。通过舱壁泳道等机制隔离失败单元(Failure Unit)，一个单元的失败不至影响其它单元的正常工作。</p><h5 id="15-自动化"><a href="#15-自动化" class="headerlink" title="15. 自动化"></a>15. 自动化</h5><p>设计和构建自动化的过程。如果机器可以做，就不要依赖于人。自动化是DevOps的基础。</p><h4 id="我的解读-1"><a href="#我的解读-1" class="headerlink" title="我的解读"></a>我的解读</h4><ol><li>这15条架构原则基本上是eBay在发展，经历过流量数量级增长冲击过程中，通过不断踩坑踩出来的，是干货中的干货。消化吸收这15条原则，基本可保系统架构不会有原则性问题。</li><li>这15条原则同样适用于现在的微服务架构。eBay发展较早，它内部其实很早(差不多2010年前)就已形成完善的微服务生态，只是没有提出微服务这个概念。</li><li>这15条原则可根据TTM(Time To Market)，可用性/可扩展性/质量，成本/效率分布在三个环内，如下图所示:</li></ol><p><img src="/images/20180521/akf.png" alt="akf"></p><h4 id="十二要素应用"><a href="#十二要素应用" class="headerlink" title="十二要素应用"></a>十二要素应用</h4><p>Heroku[附录3]是国外知名的云应用平台。基于上百万应用的托管和运营经验，创始人Adam Wiggins提出了12要素应用宣言[附录4]。简单讲，满足这12个要素的应用是比较容易云化并居住在Heroku平台上的。</p><h5 id="1-基准代码"><a href="#1-基准代码" class="headerlink" title="1. 基准代码"></a>1. 基准代码</h5><p>一份基准代码，多份部署。如果用镜像部署方式，则一个镜像可以部署到多个环境(测试，预发，生产)，而不是给每个环境制作一个不同镜像。</p><h5 id="2-依赖"><a href="#2-依赖" class="headerlink" title="2. 依赖"></a>2. 依赖</h5><p>显式声明依赖。如果用镜像部署，则一般依赖被直接打在镜像中，或者声明在docker file中。</p><h5 id="3-配置"><a href="#3-配置" class="headerlink" title="3. 配置"></a>3. 配置</h5><p>在环境中存储配置。在Heroku或者类似的PaaS平台上，配置一般是推荐注入到环境变量中的。现在采用集中式配置中心也是一种流行方式。</p><h5 id="4-后端服务"><a href="#4-后端服务" class="headerlink" title="4. 后端服务"></a>4. 后端服务</h5><p>把后端服务(例如缓存，数据库，MQ等)当作附加资源，相关配置和连接字符串通过环境变量注入，或者采用配置中心。</p><h5 id="5-构建、发布和运行"><a href="#5-构建、发布和运行" class="headerlink" title="5. 构建、发布和运行"></a>5. 构建、发布和运行</h5><p>严格分离构建和运行。如果使用镜像部署，则构建、发布/运行是通过镜像这种中间格式严格分离的。</p><h5 id="6-进程"><a href="#6-进程" class="headerlink" title="6. 进程"></a>6. 进程</h5><p>一个或者多个无状态的进程运行应用。容器运行时相当于进程，适用于无状态Web/API。</p><h5 id="7-端口绑定"><a href="#7-端口绑定" class="headerlink" title="7. 端口绑定"></a>7. 端口绑定</h5><p>通过端口绑定提供服务。容器也是通过端口绑定对外提供服务。</p><h5 id="8-并发"><a href="#8-并发" class="headerlink" title="8. 并发"></a>8. 并发</h5><p>通过进程模型进行扩展。容器运行时相当于进程，通过起多个容器可以任意扩展并发数量。</p><h5 id="9-易处理"><a href="#9-易处理" class="headerlink" title="9. 易处理"></a>9. 易处理</h5><p>快速启动和优雅终止可最大化健壮性。docker容器支持秒级启动和关闭。</p><h5 id="10-开发环境和线上环境等价"><a href="#10-开发环境和线上环境等价" class="headerlink" title="10. 开发环境和线上环境等价"></a>10. 开发环境和线上环境等价</h5><p>尽可能保持开发、测试、预发和线上环境相同。容器可以保证容器内运行时环境的一致性，还需要保证不同环境的一致性，例如不同环境内的操作系统，负载均衡，服务发现，后台服务，监控告警等要尽可能一致。</p><h5 id="11-日志"><a href="#11-日志" class="headerlink" title="11. 日志"></a>11. 日志</h5><p>把日志当作数据流。Heroku不支持本地文件，所以必须以流方式把日志输送到后台日志服务。除了日志以外还要补充考虑metrics流的采集和输送。</p><h5 id="12-管理进程"><a href="#12-管理进程" class="headerlink" title="12. 管理进程"></a>12. 管理进程</h5><p>后台管理任务当作一次性的进程。其实相当于在Heroku上以独立进程方式运行任务Job。</p><h4 id="我的解读-2"><a href="#我的解读-2" class="headerlink" title="我的解读"></a>我的解读</h4><ol><li>12要素应用也是当前云原生应用(Cloud Native App)的参考标准，我把这12要素也称为云应用迁移原则。满足这12个要素的应用，可以比较顺利迁移到各种云平台(Kubernetes, Marathon, Cloud Foundry等)上。</li><li>对于面临企业遗留应用改造和云化迁移的架构师，可以重点参考这12条迁移原则。</li><li>Docker容器技术可以认为是为云迁移量身定制的技术。容器化是后续云迁移的捷径，所以遗留应用改造可以先想办法做到容器化。</li></ol><h4 id="CAP定理"><a href="#CAP定理" class="headerlink" title="CAP定理"></a>CAP定理</h4><p>2000年7月，加州大学伯克利分校的Eric Brewer教授在ACM PODC会议上提出CAP猜想。2年后，麻省理工学院的Seth Gilbert和Nancy Lynch从理论上证明了CAP。之后，CAP理论正式成为分布式计算领域的公认定理。</p><p>CAP认为：一个分布式系统最多同时满足一致性(Consistency)，可用性(Availability)和分区容忍性(Partition Tolerance)这三项中的两项。</p><h5 id="1-一致性-Consistency"><a href="#1-一致性-Consistency" class="headerlink" title="1. 一致性(Consistency)"></a>1. 一致性(Consistency)</h5><p>一致性指“all nodes see the same data at the same time”，即更新操作成功，所有节点在同一时间的数据完全一致。</p><h5 id="2-可用性-Availability"><a href="#2-可用性-Availability" class="headerlink" title="2. 可用性(Availability)"></a>2. 可用性(Availability)</h5><p>可用性指“Reads and writes always succeed”，即服务一直可用，而且响应时间正常。</p><h5 id="3-分区容忍性-Partition-tolerance"><a href="#3-分区容忍性-Partition-tolerance" class="headerlink" title="3. 分区容忍性(Partition tolerance)"></a>3. 分区容忍性(Partition tolerance)</h5><p>分区容忍性指“the system continue to operate despite arbitrary message loss or failure of part of the system.”，即分布式系统在遇到某节点或网络分区故障时，仍然能够对外提供满足一致性和可用性的服务。</p><p><img src="/images/20180521/cap.png" alt="cap"></p><h4 id="BASE理论"><a href="#BASE理论" class="headerlink" title="BASE理论"></a>BASE理论</h4><p>eBay架构师Dan Pritchett基于对大规模分布式系统的实践总结，在ACM上发表文章提出了BASE理论，BASE理论是对于CAP理论的延伸，核心思想是即使无法做到强一致性(Strong Consistency，CAP中的一致性指强一致性)，但是可以采用适当的方式达到最终一致性(Eventual Consistency)。</p><p>BASE指基本可用(Basically Available)、软状态(Soft State)和最终一致性(Eventual Consistency)。</p><h5 id="1-基本可用-Basically-Available"><a href="#1-基本可用-Basically-Available" class="headerlink" title="1. 基本可用(Basically Available)"></a>1. 基本可用(Basically Available)</h5><p>基本可用是指分布式系统在出现故障时，允许损失部分可用性，即保证核心可用。比如服务降级。</p><h5 id="2-软状态-Soft-State"><a href="#2-软状态-Soft-State" class="headerlink" title="2. 软状态(Soft State)"></a>2. 软状态(Soft State)</h5><p>软状态是指允许系统存在中间状态，而该中间状态不会影响系统的整体可用性。分布式存储中一般一份数据至少存三个副本，允许不同节点间副本同步的延迟就是软状态的体现。</p><h5 id="3-最终一致性-Eventual-Consistency"><a href="#3-最终一致性-Eventual-Consistency" class="headerlink" title="3. 最终一致性(Eventual Consistency)"></a>3. 最终一致性(Eventual Consistency)</h5><p>最终一致性是指系统中的所有数据副本经过一段时间后，最终能够达成一致状态。弱一致性和强一致性相反，最终一致性是弱一致性的一种特殊情况。</p><p><img src="/images/20180521/base.png" alt="base"></p><h4 id="我的解读-3"><a href="#我的解读-3" class="headerlink" title="我的解读"></a>我的解读</h4><ol><li>CAP和BASE理论可以抠得很深，背后甚至有很复杂的数学证明。我理解得相对简单浅显：性能、高可用、不丢数据和数据一致性对分布式系统来说一般是强需求，随着流量的增长，复制和分区在所难免：<ul><li>复制(replication)：数据在多个节点上存多份保证不丢和高可用；</li><li>分区(partition)：数据按某个纬度切分分布在不同节点上分摊流量压力保证高性能，同时也是为了降低每个节点的复杂性。例如数据库的分库分表，系统拆分微服务化也是一种分区。<br>这两者都会带来一致性问题，一致性在时间上有一点妥协的余地-即是最终一致性；时间上要求强一致的话，只有可用性可以适当折中。系统架构的游戏很大部分是和状态一致性作斗争的游戏。</li></ul></li><li>选择使用分布式产品时，比如NoSQL数据库，你需要了解它在CAP环中所在的位置，确保它满足你的场景需要。</li></ol><h3 id="三、组织和系统改进原则"><a href="#三、组织和系统改进原则" class="headerlink" title="三、组织和系统改进原则"></a>三、组织和系统改进原则</h3><h4 id="康威法则"><a href="#康威法则" class="headerlink" title="康威法则"></a>康威法则</h4><p>Melvin Conway在1967年提出所谓康威法则[附录5]，指出组织架构和系统架构之间有一种隐含的映射关系：</p><blockquote><p>Organization which design system […] are constrained to produce designs which are copies of the communication structures of these organization. 设计系统的组织其产生的设计等价于组织间的沟通结构。</p></blockquote><p><img src="/images/20180521/conway_law_1.png" alt="conway&#39;s law 1"></p><p>康威法则也可以倒过来阐述：</p><blockquote><p>Conway’s law reversed：You won’t be able to successfully establish an efficient organization structure that is not supported by your system design(architecture)。  如果系统架构不支持，你无法建立一个高效的组织；同样，如果你的组织架构不支持，你也无法建立一个高效的系统架构。</p></blockquote><p><img src="/images/20180521/conway_law_2.png" alt="conway&#39;s law 2"></p><h4 id="系统改进三原则"><a href="#系统改进三原则" class="headerlink" title="系统改进三原则"></a>系统改进三原则</h4><p>IT运维管理畅销书《凤凰项目》[附录8]的作者Gene Kim在调研了众多高效能IT组织后总结出支撑DevOps运作的三个原理(The Three Ways: The Principles Underpinning DevOps)[附录9]，我认为也是系统改进提升的一般性原理[附录7]，见下图：</p><p><img src="/images/20180521/system_thinking.png" alt="system thinking"></p><h5 id="原理一：系统思考-System-Thinking"><a href="#原理一：系统思考-System-Thinking" class="headerlink" title="原理一：系统思考(System Thinking)"></a>原理一：系统思考(System Thinking)</h5><p>开发驱动的组织，其能力不是制作软件，而是持续的交付客户价值。价值从业务需求开始，经过研发测试，到部署运维，依次流动，并最终以服务形式交付到客户手中。整个价值链流速并不依赖单个部分(团队或个人)的杰出工作，而是受整个价值链最薄弱环节(瓶颈)的限制。所以局部优化通常无效，反而招致全局受损。</p><p>Gene Kim特别指出：</p><blockquote><p>Any improvements made anywhere besides the bottleneck are an illusion. 在瓶颈之外的任何优化提升都只是幻象。</p></blockquote><h5 id="原理二：强化反馈环-Amplify-Feedback-Loops"><a href="#原理二：强化反馈环-Amplify-Feedback-Loops" class="headerlink" title="原理二：强化反馈环(Amplify Feedback Loops)"></a>原理二：强化反馈环(Amplify Feedback Loops)</h5><p>过程改进常常通过加强反馈环来达成。原理二强调企业和客户之间、组织团队间、流程上和系统内的反馈环。没有测量就没有提升，反馈要以测量数据为准，通过反馈数据优化改进系统。</p><h5 id="原理三：持续试验和学习的文化-Culture-of-Continual-Experimentation-And-Learning"><a href="#原理三：持续试验和学习的文化-Culture-of-Continual-Experimentation-And-Learning" class="headerlink" title="原理三：持续试验和学习的文化(Culture of Continual Experimentation And Learning)"></a>原理三：持续试验和学习的文化(Culture of Continual Experimentation And Learning)</h5><p>在企业管理文化层面强调勇于试错和持续试验、学习和改进的文化。</p><h4 id="我的解读-4"><a href="#我的解读-4" class="headerlink" title="我的解读"></a>我的解读</h4><ol><li>康威法则给我们的启示：系统架构和组织架构之间有隐含的映射关系，你不能单方面改变一方的结构，调整时必须两边联动。系统架构如果是耦合的，就很难组织分散式的团队结构，两边映射不起来，团队之间容易摩擦导致生产率下降。所以一般先按业务边界对单块应用进行解耦拆分，同时做相应的团队拆分，使两边可以映射，每个团队可以独立开发、测试和部署各自的微服务，进而提升生产率。这就是近年流行的微服务架构背后的组织原则。详见我之前发表的文章《企业的组织架构是如何影响技术架构的》[附录6]。</li><li>系统思考要求我们加强团队合作，培养流式思维和瓶颈约束思维，找出瓶颈并针对性地优化。在研发型组织中，常见的系统瓶颈如运维机器资源提供(Provisioning)缓慢，发布流程繁琐容易出错，开发/测试／UAT环境缺失或不完善，遗留系统耦合历史负担重，基础研发平台薄弱等等。这些瓶颈点特别需要关注优化。</li><li>反馈原理要求我们关注基于数据的反馈，技术上的手段包括大数据分析和系统各个层次的测量监控。没有测量就没有反馈，没有反馈就没有提升。</li><li>在管理文化层面：<ul><li>管理层要承认企业内部近50%的创新或流程改进项目是有可能失败的，即使失败，员工不会受到责罚，鼓励持续的试验和从中学习；</li><li>管理层要有技术偿债意识，勿追求100%员工利用率，要预留20%~30%的时间给员工做创新和系统改进提升项目。</li></ul></li></ol><h3 id="四、写在最后"><a href="#四、写在最后" class="headerlink" title="四、写在最后"></a>四、写在最后</h3><p>上述原则是架构师必须深入理解和掌握的，但是不能盲从，实际工作中要根据业务、时间、资源和团队情况随机应变。原则有时甚至可以被违反，当然这样做一定有成本，架构师要意识这一点，并适时变通补偿。</p><p>上述原则仅是我个人视角总结，有些理解难免偏颇。如果你认为我忽略了哪些重要的原则，或理解有误，请记得线下和我交流！</p><h3 id="五、附录"><a href="#五、附录" class="headerlink" title="五、附录"></a>五、附录</h3><ol><li><a href="https://www.amazon.cn/UML%E5%92%8C%E6%A8%A1%E5%BC%8F%E5%BA%94%E7%94%A8-%E6%8B%89%E6%9B%BC/dp/B00116WMSU" target="_blank" rel="noopener">UML和模式应用(原书第3版)</a></li><li><a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B01DXW29IM" target="_blank" rel="noopener">架构即未来：现代企业可扩展的Web架构、流程和组织(原书第2版)</a></li><li><a href="https://www.heroku.com/" target="_blank" rel="noopener">Heroku云应用平台</a></li><li><a href="https://12factor.net/zh_cn/" target="_blank" rel="noopener">The Twelve-Factor App</a></li><li><a href="https://en.wikipedia.org/wiki/Conway%27s_law" target="_blank" rel="noopener">康威法则</a></li><li><a href="http://www.infoq.com/cn/articles/organization-arch-influence-technology-arch" target="_blank" rel="noopener">企业的组织架构是如何影响技术架构的</a></li><li><a href="http://www.sohu.com/a/123304174_467759" target="_blank" rel="noopener">痛定思痛，谈成长型公司应该如何突破方轮子困局!</a></li><li><a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B016VW1I6U" target="_blank" rel="noopener">凤凰项目：一个IT运维的传奇故事</a></li><li><a href="https://itrevolution.com/the-three-ways-principles-underpinning-devops/" target="_blank" rel="noopener">The Three Ways: The Principles Underpinning DevOps</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;如果一个技术已经存在3年，比如现在很火的前端技术react和vue等，那么我能预估这个技术大致还有3年的生命期，再久就不确定了；如果一个架构或设计原则已经存在15年，例如单一职责和依赖倒置原则，我可以预期它还有15年甚至更久的生命期。原则是比具体技术更抽象，更接近事物本质，也更经得起时间考验的东西。这些原则沉淀在架构师的脑海中，最终内化成他的mindset，以潜意识方式影响和指导他的架构和设计工作。&lt;/p&gt;
&lt;p&gt;一晃我在软件研发行业工作十多个年头了，前面大部分时间做架构设计和开发，现在转型做研发管理。随着时间的推移，很多技战术细节性的东西(工具，框架，编程语言)在我脑海中渐渐模糊，但是一些平时学习积累起来，并且在实践中加深体会的软件架构设计和组织原则，这些原则性的东西却丝毫没有被时间冲淡，反而愈加清新。现在即使我不在一线开发，但这些沉淀下来的原则仍然潜移默化地影响我的日常管理和部分架构设计指导工作。我想有必要总结一下那些业界知名，给我留下深刻印象的软件架构设计和组织原则，和大家一起分享。&lt;/p&gt;
    
    </summary>
    
      <category term="系统架构" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构设计" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
  <entry>
    <title>工程师成长快车道</title>
    <link href="http://yoursite.com/2018/05/20/20180520/"/>
    <id>http://yoursite.com/2018/05/20/20180520/</id>
    <published>2018-05-20T05:54:50.000Z</published>
    <updated>2018-06-15T07:13:44.858Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>今年公司来了不少应届生还有实习生，我多次受邀给他们做一些和成长相关的分享，获得良好反馈，我想可以把这些分享总结成文，一方面下次自己就不用频繁去讲，新人来让他们看文章就好了，另一方面也是想把自己的心得分享给更多社会上的处在职业早期的年轻人。</p><p>我本人在软件研发行业工作有十多年，经历过不少公司，见证过不少年轻人的成长，自己也带过很多年轻人。从他们的成长历程中，我看到那些成长较快的年轻人身上有一些共性的东西，下面是我对这些共性的总结和分享，期望对大家有帮助，让更多人更快步入成长快车道。</p><a id="more"></a><p>卡耐基在《人性的弱点》一书中提出”一个人事业上的成功，只有15%是由于他的专业技术，另外的85%要依赖于他的软性技能”，我非常认同这个论断，很多步入成长快车道的年轻人身上的特质也验证了这个论断，所以本分享不涉及专业技能(这块是被假定你必须有的)，而主要是关于软性技能的。</p><h3 id="一、思维转型"><a href="#一、思维转型" class="headerlink" title="一、思维转型"></a>一、思维转型</h3><p>中国式教育，学生被灌输因果确定的东西比较多(没有标准答案的东西老师没办法考试)，在学校呆久容易形成因果确定式思维。但是社会完全不一样，很多东西是非线性不确定的，有很多东西不仅没有标准答案，很多时候连问题是什么都不知道，你需要自己去找问题再提出解决办法。</p><p>下图(来自《管理3.0》)把我们的世界根据不确定性划分为四个区域：</p><ol><li>简单区(Simple)：一张桌子，一本书是比较简单的事物，比较确定</li><li>结构复杂区(Complicated)：计算机结构非常复杂，但仍然是确定性的</li><li>交互复杂区(Complex)：城市，公司，社会交互非常复杂，不确定性大</li><li>混沌区(Chaotic)：股市充满不确定性</li></ol><p><img src="/images/20180520/mgmt30.png" alt="mgmt3.0"></p><p>我们在学校学习的东西大都处于简单和结构复杂区域，相对比较确定；而社会和公司则处在交互复杂甚至混沌区，有很多不确定性。顺便提一下有意思的一点，生命和创新常常发生在交互复杂和混沌的边缘。另外一个很有意思的观察是：机械和死的东西大都处在简单或者结构复杂区；而有活力和生机的东西大都处在交互复杂甚至混沌区。这一观察和人类追求确定性的本能其实是非常矛盾的，但对我们很有启发性。</p><p>应届生刚从学校步入企业和社会，他们首先需要面对的是思维转型的问题，从线性确定思维切换到非线性不确定思维。有的人这种切换会花很多年(也有人一直切换不过来的)，有的会比较快，切换快的成长也快。</p><h3 id="二、积极主动"><a href="#二、积极主动" class="headerlink" title="二、积极主动"></a>二、积极主动</h3><p>这是个老生常谈话题，不想展开太多，简单几句：职业最终是你自己的职业，不是你老板的职业，你要为自己的职业负全责。不要等着被叫去做事，否则你会非常亏 ~ 不主动做事，别以为你占了老板便宜，老板不会多给薪水事小，关键不做事情你就没有成长，你最有价值的时间被浪费掉了！</p><p>从以往经验看，总体上胆大主动型的应届生的成长要远远快于胆小被动型的应届生。</p><p><img src="/images/20180520/proactive.jpg" alt="proactive"></p><h3 id="三、成长式思维"><a href="#三、成长式思维" class="headerlink" title="三、成长式思维"></a>三、成长式思维</h3><p>如果有人问我对一个人成长影响最重要的因素，我会毫不犹豫回答是成长式思维，简单讲是空杯心态。</p><p><img src="/images/20180520/glass.jpg" alt="glass"></p><p>如果你的杯子是空的，新东西就比较容易进去；反之，如果你的杯子已经满了，新东西就进不去。有一小部分自以为是的同学，他们才刚从学校出来思维就固化得有点像小老头，他们自己的东西太多，顽固又不肯放弃(清空杯子)，新东西自然难进去，成长自然就慢；具有空杯心态的同学，他们会适时清空自己，甚至有意识清除脑中顽固区域，虚心主动学习，如乔布斯所言：stay hungry, stay foolish(求知若饥，虚心若愚)，拥有这种心态成长岂能不快？</p><p>下图展示僵固式心智和成长式心智的差异。本质上两者在智力能力是确定还是不确定的根本性世界观不同，造成他们在面对挑战、挫折、努力、批评和别人的成功时，所表现出来的行为就完全不同。最终前者的人生会一直停留在平滑的直线上，完全没有发挥自己的潜能；而后者则不断攀登人生的高峰，并充分感受到自由意志的伟大力量。</p><p><img src="/images/20180520/growth.jpg" alt="growth"></p><h3 id="四、合作和沟通"><a href="#四、合作和沟通" class="headerlink" title="四、合作和沟通"></a>四、合作和沟通</h3><p>如果客观事实是一个圆的话，我们每个人由于背景经验和视角的不同，只能看到其中的一小部分扇形，对这些不同扇形的认知有的时候还是相互冲突的，只有将不同的小扇型拼起来，才有可能趋近真相。你越是善于合作沟通，通过别人的眼睛看世界，那么你越容易接近真相，成长越快。一个人成熟标志之一是知道个人的能力和视角都是有限的，必须与不同专业背景的人合作互补才能成就更大的事业。</p><p><img src="/images/20180520/perspective.jpg" alt="perspective"></p><p>下图来自《部落的力量》一书，把不同企业的文化根据成熟度划分为五个阶段，其实对人也适用。我们大部分人都会分布在2/3/4三个阶段(1/5阶段的人会比较少)，一般团队中会有1/4的冷漠受害者，1/2的孤独勇士，1/4的稳定合作者。由于中国式教育本质上还是应试分数教育，我们会培养出不少崇尚竞争缺乏合作精神的所谓“牛人”。牛人需锻炼领悟成熟了才会进化到稳定合作者，领悟越早成长越快。</p><p><img src="/images/20180520/5stage.jpg" alt="5 stages"></p><h3 id="五、天赋-勤奋-热情"><a href="#五、天赋-勤奋-热情" class="headerlink" title="五、天赋+勤奋+热情"></a>五、天赋+勤奋+热情</h3><p>经常被问：人的成才，是天赋更重要的一点？还是勤奋更重要一点？</p><p>西方文化比较崇尚天赋论，我刚进亿贝中国研发中心那会儿，老板给每个员工发一本书叫《发挥你的优势》，这本书的核心思想偏天赋论 – 造物机缘赋予每个人某些优势，分别适合不同的行业和角色，你不需要瞎折腾，好好发掘并磨砺你的优势就会变得非常厉害。</p><p><img src="/images/20180520/strength_finding.jpg" alt="strength finding"></p><p>东方文化比较崇尚勤奋论，其实西方也有类似所谓1万小时的理论(见《异类》一书)：甭管天赋，正常人只要专注某个领域刻苦练习1万小时(每天练习3小时，需要10年，每天练习6小时，则需5年)，都能成为这个领域的专家变得很厉害。</p><p><img src="/images/20180520/outliers.jpg" alt="outliers"></p><p>我的经验是天赋和勤奋相辅相成，都会发挥作用。理想是两者兼备，你有大概率会成就卓越，但是如果你天赋不足，靠死磕1万小时也能成才。</p><p>在天赋和勤奋基本达标的前提下，我本人其实更关注热情和兴趣，我见过很多其实资质并不高的人，但是做事勤奋主动有热情，努力坚持成为行业中坚；相反一些早期资质不错但是做事不专没有热情的人，到最后反而大都没成。</p><h3 id="六、导师"><a href="#六、导师" class="headerlink" title="六、导师"></a>六、导师</h3><p>没有导师能成才吗？我想也能，但是常常会走更多弯路花费更高的学习成本，导师的作用在于指导你少走弯路，更快成长。</p><p>我职业早年主要靠单打独斗多一点，成长就比较慢，后来有幸碰到几位不错的导师，给我很多指导和帮助，期间我的成长加速了，原来要花5年学的东西，在导师的指点下1年就可以学到。我也见过有应届生一开始就幸运碰到好导师的，在导师指导下很早投入高质量的项目开发锻炼，只用3年左右时间就从应届生快速成长为高级研发经理。</p><p><img src="/images/20180520/turtor.jpg" alt="turtor"></p><p>寻找好的导师是你自己的责任，你要找导师，其实导师也在找你。高水平的导师是非常愿意投资有潜力的年轻人，但是一开始你的潜力不明显，核心竞争力和产出都低，并不能入导师的法眼。所以在找到好的导师之前，专注积累和打磨自己核心竞争力和提升自己的价值是关键。</p><h3 id="七、学习-实践"><a href="#七、学习-实践" class="headerlink" title="七、学习+实践"></a>七、学习+实践</h3><p>这又是一个老生常谈的话题问题，我所知道的牛人都是学习狂，据说我们公司的CXO每周都是要看1~2本书的。你至少每个月要看1本书，这个量积累10年的话可以超过100本，这时你的见识和水平应该不会太差。当然看书要尽量看经典名著，经过时间筛选沉淀下来的好作品，朋友圈蜻蜓点水式的学习效果并不大。</p><p><img src="/images/20180520/reading.png" alt="reading"></p><p>同时工作中要力争好的项目实战锻炼，才能成长更快。这里头有个矛盾，刚开始你产出低价值小，一般很难获得高质量的项目，这个时候不要气馁因为你还在积累期。刚开始轮不到你挑三拣四，杂活累活都要干，注意积累自己的核心竞争和价值；后面你有经验了，对自己和项目有更明确的价值判断，就要有选择性的挑价值更大对自己成长更有利的项目。</p><h3 id="八、客户、产出和价值意识"><a href="#八、客户、产出和价值意识" class="headerlink" title="八、客户、产出和价值意识"></a>八、客户、产出和价值意识</h3><p>这也是很重要的一个思维切换。在校生一般由家庭资助，主要关注自己的学习成绩，大部分几乎没有直接价值产出。但是社会和公司完全不同，商业世界的正常运作完全构建于人于人之间的价值交换基础之上。简单讲，老板把你招进公司并支付给你薪水，根本上是指望你给他创造价值的(通过直接或间接为客户提供价值的方式)。</p><p><img src="/images/20180520/customer.jpg" alt="customer"></p><p>坦白讲，大部分应届生在职业前面几年价值产出都不大的，公司还要花费成本培养。这就需要你尽快建立起客户、产出和价值意识，尤其要珍惜前面几年的培养积累期，在逐步打磨自己核心价值的同时，不断提升自己的价值输出。每半年都要扪心自问：这半年我个人的核心价值提升了没有？我给团队和公司的产出是什么？价值在哪里？下面半年我该如何提升产出和价值？你的价值输出越大，回报就越大，成长空间就大；反之回报就小，成长就慢，那些没有价值输出的人常常处在被淘汰的边缘。</p><h3 id="九、目标设定-时间管理"><a href="#九、目标设定-时间管理" class="headerlink" title="九、目标设定+时间管理"></a>九、目标设定+时间管理</h3><p>耶鲁大学进行过一次跨度20年的跟踪调查。最早，研究人员对参加调查的学生提了一个问题：“你们有目标吗？”10%的学生回答没有。研究人员又问：“如果你有了目标，是否把它写下来呢？”这时，只有4%学生回答是。</p><p>20年后，研究人员跟踪当年参加调查的学生。结果发现，那些有目标并且用白纸黑字写下来的学生，无论在事业发展还是生活水平，都远远超过了另外的没有这样做的学生。他们超越余下的96%的学生的总和。那么，那96%的学生今天在干什么呢？研究人员发现，这些人忙忙碌碌，一辈子都在直接或间接地帮助那4%的人在实现他们的人生目标。</p><p>没有目标和计划的人生，犹如大海中没有舵只能随波逐流的航船，时间流逝了，但是始终无法到达目的地。远大目标+细化的阶段性目标+周密的执行计划，能助你快速成长。</p><p><img src="/images/20180520/goal.png" alt="goal"></p><p>同时，现代社会节奏越来越快，如分不清事情的轻重缓急，我们非常容易迷失在琐事中，每天忙忙碌碌，但是成长缓慢。Stephen R. Covey在《高效能人士的七个习惯》中，给我们提供了一个很好的时间管理模型-四象限工作法则：</p><ul><li><strong>A重要但不紧急</strong>：通常是一些有长期价值的事情，比如提升个人职场竞争力，学习和阅读，家庭和朋友，身体和锻炼，投资等等</li><li><strong>B既重要又紧迫</strong>：通常是一些火烧眉毛的事情，比如工作或生活中的危机。</li><li><strong>C既不重要也不紧急</strong>：上网聊天打游戏常属于该象限，偶尔放松一下可以，但不可沉溺于此</li><li><strong>D不重要但是紧急</strong>：通常是别人的优先级，或者可以委派出去的事情</li></ul><p>我们的注意力主要应该放在和重要性相关的两个象限里头。这两个象限的时间分配是门平衡的艺术。理想状态，70%的时间应该放在A象限(即未雨绸缪)象限。20%的时间放在B象限(用于应急)。A象限做好了，B象限事件发生的概率会变小。如果一个人大部分时间在B象限救急，说明他A/B象限的时间分配失衡或倒挂，需要关注投资那些长期重要但不紧急的事情。</p><p><img src="/images/20180520/priority.png" alt="priority"></p><p>目标设定和时间管理是可以通过实践积累的实用技能，这些习惯在职业初期越早养成，成长就越快。</p><h3 id="十、坚韧不拔-长线思维"><a href="#十、坚韧不拔-长线思维" class="headerlink" title="十、坚韧不拔+长线思维"></a>十、坚韧不拔+长线思维</h3><p>上面讲到目标设定，假定你设定了远大人生目标和阶段性计划，是否可以直线达到？当然不是这样的，中间难免会有各种坑坑洼洼和挫折(人生的乐趣尽在于此:))，下面这个图很形象表达现实的曲折性和不确定性。所以目标设定只是万里长征第一步，你还需要锲而不舍的毅力+执行才有可能达成目标。当然目标也不是完全固定不变的，你需要随环境变化不断调整目标。</p><p><img src="/images/20180520/reality.jpg" alt="reality"></p><p>成功是一条长长的抛物线，成功的应届生除了具备良好耐挫能力和执行力，同时还具有长线思维。怎么算长线思维？其实1年3年都不算长，我们读个大学都需要4年。一般来说，一个人在一家公司能真正的成长并做出一些成绩，大致需要不少于5年的积累，建议应届生以5年为周期来规划自己的职业目标。特别是职业初期，不宜频繁换工作，否则很难形成积累。</p><h3 id="十一、反脆弱和舒适区"><a href="#十一、反脆弱和舒适区" class="headerlink" title="十一、反脆弱和舒适区"></a>十一、反脆弱和舒适区</h3><p>如果我问大家，脆弱的反义词是什么？很多人的回答是坚固。我们说玻璃杯是脆弱的，因为一不小心掉在地上就容易碎掉；城堡普遍认为是坚固的，但是历史告诉我们，像城堡和长城这些所谓坚固的东西被敌人攻破的案例数不胜数。自然界还有一类事物(它们大都处于交互复杂和混沌区)，例如生物DNA，还有我们身上的肌肉，它们在适度压力甚至打击下，不仅不会消亡，反而会更加健壮。《反脆弱》一书的作者据此者提出了反脆弱理念，该理念可以应用于社会生活政治经济等各个领域。它给我们一个很好的启示：人类本身是具有反脆弱性的，提升一个人能力的办法，并不是将他保护起来，减少他接触不确定性的机会(因为无法避免的黑天鹅事件的存在，这样做反而使其脆弱)，而是将其暴露在有适度压力和不确定的环境中，靠自然反脆弱力使其茁壮成长。</p><p><img src="/images/20180520/anti_fragile.png" alt="anti_fragile"></p><p>管理学中有一个类似的理念叫突破舒适区。一个事情做久了，或者一个地方呆久了，人会产生舒适区，当走出舒适区之外时，人会感觉不舒服，所以大部分人都乐意呆在舒适区里头，但是这样会阻碍其成长。</p><p>在舒适去之外的那个环叫做学习区，进入这个区域虽然让你感觉不舒服，但是可以获得学习成长。有反脆弱和突破舒适区意识的人，会经常性的走出舒适区，做一些让自己不怎么舒服的事情，借此拓展提升自己的能力。据我所知，像一些企业家经常有一些自我挑战行为，比如徒步沙漠，攀爬珠峰，其实也是一种自发突破舒适区的行为。应届生在成长过程中经常要自省：如果某个事情做得得心应手了，是否该尝试新挑战；挑战过程中如果感觉到不舒服了，能否客观看待这种自然的学习反映，而不是被情绪牵着走轻易放弃？这样的自省行为会让你成长更快。</p><p><img src="/images/20180520/comfort_zone.png" alt="comfort zone"></p><h3 id="十二、从优秀到卓越"><a href="#十二、从优秀到卓越" class="headerlink" title="十二、从优秀到卓越"></a>十二、从优秀到卓越</h3><p>大家能通过筛选，进入公司，说明大家都很优秀，在此基础上，我们如何才能做到卓越呢？最近阅读《从优秀到卓越》一书让我深受启发。作者跟踪调研了几十家实现从优秀到卓越跨越的公司，发现他们都遵循一个三环理念，我觉得这个理念同样也适用于应届生成长，三环如下图所示，分别是：</p><ul><li>潜力圈： 你哪些方面的天赋潜能，如果挖掘出来的话可能在同辈中做到Top10的？</li><li>热情圈：你做哪些事情的时候充满热情，可以全情投入甚至忘却时间的流逝？</li><li>价值圈：你做哪些事情可以给公司/客户和你自己带来巨大经济回报？</li></ul><p><img src="/images/20180520/3loop.png" alt="3 loops"></p><p>如果一个人能将三环完美结合 ~ 我从事的事业能最大限度发挥我的潜能，我对此事又乐此不疲，而且从中我还能获得巨大的经济回报，那么非常恭喜你，你是人群中极少数有可能实现从优秀到卓越跨越的幸运儿。如果三环不能有机结合，则一般很难达到优秀更别说卓越。</p><p>我们大部分人一开始都是懵懂懵懂的，并不清楚这三环和自己的关系，一般需要折腾几年才会清楚的认识自己。所以职业生涯前面几年你有一项非常重要的任务：认识你自己，同时也要认识你周围的社会环境。人越早认识自己，成长越快空间越大。能实现三环叠加的人，终将实现从优秀到卓越的跨越，开启幸福人生！</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>讲了这么多，下面来一个小结：</p><ol><li><strong>良好的心态是关键</strong>，上面讲的80%的内容，其实是关于心态的。这个是”道”或者说是智慧，需要长年沉潜内修和领悟方能获得，再怎么强调也不为过。</li><li><strong>辛勤的汗水付出少不了</strong>，没有付出就没有收获。</li><li><strong>需要一点组织性+纪律性</strong>，目标设定+计划+执行。</li><li><strong>拥抱不确定性</strong>，世界本质上是不确定的，这也正是其迷人之处。</li><li><strong>认识你自己</strong>，才能发挥三环威力实现从优秀到卓越的跨越。</li><li><strong>运气</strong>，因为不确定性凡事需要一点运气，总体上做好上面这些点，你的运气应该不会太差</li></ol><p>成功从来都不是一蹴而就的，需要长年坚忍不拔的努力。世界名著大仲马的《基督山伯爵》结尾说，人类最大的智慧其实就是：希望+等待，同样地我想把这个智慧传递给所有年轻人：满怀希望，积极等待！</p><p>最后送给大家一首我个人非常喜欢的小诗：</p><blockquote><p>莫怕孤独，<br>你所爱的一样也没有失去，<br>就象暗夜里那颗遥远的星，<br>纵然你永远无法抵达，<br>但始终照亮着你生命的行程。</p></blockquote><p>参考书</p><ol><li><a href="https://www.amazon.cn/%E4%BA%BA%E6%80%A7%E7%9A%84%E5%BC%B1%E7%82%B9%E5%85%A8%E9%9B%86-%E6%88%B4%E5%B0%94-%E5%8D%A1%E5%86%85%E5%9F%BA/dp/B008F5WMEE" target="_blank" rel="noopener">人性的弱点全集</a></li><li><a href="https://www.amazon.cn/%E7%AE%A1%E7%90%863-0-%E5%9F%B9%E5%85%BB%E5%92%8C%E6%8F%90%E5%8D%87%E6%95%8F%E6%8D%B7%E9%A2%86%E5%AF%BC%E5%8A%9B-%E9%98%BF%E4%BD%A9%E7%BD%97/dp/B007H4NQ26" target="_blank" rel="noopener">管理3.0：培养和提升敏捷领导力</a></li><li><a href="https://www.amazon.cn/%E9%83%A8%E8%90%BD%E7%9A%84%E5%8A%9B%E9%87%8F-%E6%88%B4%E5%A4%AB-%E6%B4%9B%E6%A0%B9-%E7%BA%A6%E7%BF%B0-%E9%87%91-%E6%B5%B7%E4%B8%BD-%E8%B4%B9-%E8%8E%B1%E7%89%B9/dp/B00P8RCEQI" target="_blank" rel="noopener">部落的力量</a></li><li><a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B016XWUHWY" target="_blank" rel="noopener">现在，发现你的优势</a></li><li><a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00JD436FA" target="_blank" rel="noopener">异类：不一样的成功启示录</a></li><li><a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00OOLUCAY" target="_blank" rel="noopener">高效能人士的七个习惯</a></li><li><a href="https://www.amazon.cn/%E5%9B%BE%E4%B9%A6/dp/B00GYLFKEA" target="_blank" rel="noopener">反脆弱：从不确定性中获益</a></li><li><a href="https://www.amazon.cn/%E4%BB%8E%E4%BC%98%E7%A7%80%E5%88%B0%E5%8D%93%E8%B6%8A-%E5%90%89%E5%A7%86-%E6%9F%AF%E6%9E%97%E6%96%AF/dp/B002USB4FA" target="_blank" rel="noopener">从优秀到卓越</a></li><li><a href="https://www.amazon.cn/%E5%9F%BA%E7%9D%A3%E5%B1%B1%E4%BC%AF%E7%88%B5-%E5%A4%A7%E4%BB%B2%E9%A9%AC/dp/B003YYSFPG" target="_blank" rel="noopener">基督山伯爵</a></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;今年公司来了不少应届生还有实习生，我多次受邀给他们做一些和成长相关的分享，获得良好反馈，我想可以把这些分享总结成文，一方面下次自己就不用频繁去讲，新人来让他们看文章就好了，另一方面也是想把自己的心得分享给更多社会上的处在职业早期的年轻人。&lt;/p&gt;
&lt;p&gt;我本人在软件研发行业工作有十多年，经历过不少公司，见证过不少年轻人的成长，自己也带过很多年轻人。从他们的成长历程中，我看到那些成长较快的年轻人身上有一些共性的东西，下面是我对这些共性的总结和分享，期望对大家有帮助，让更多人更快步入成长快车道。&lt;/p&gt;
    
    </summary>
    
      <category term="技术管理" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF%E7%AE%A1%E7%90%86/"/>
    
    
      <category term="工程师成长" scheme="http://yoursite.com/tags/%E5%B7%A5%E7%A8%8B%E5%B8%88%E6%88%90%E9%95%BF/"/>
    
  </entry>
  
  <entry>
    <title>波波的架构理念</title>
    <link href="http://yoursite.com/2018/05/17/20180517/"/>
    <id>http://yoursite.com/2018/05/17/20180517/</id>
    <published>2018-05-17T08:57:58.000Z</published>
    <updated>2018-06-15T07:45:55.441Z</updated>
    
    <content type="html"><![CDATA[<h3 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h3><p>近期我会陆陆续续把我之前在infoq/聊聊架构等媒体上发表的文章，陆续搬到我的个人公众号《波波微课》，这个是第一篇。</p><p>这篇有特殊的意义，2015年下半年的时候，我还没有养成定期总结梳理的习惯，是极客邦的郭蕾鼓励我尝试。今天回头看，这个投资有很大价值，这一路积累了不少东西，后面需要持续积累，将价值和影响力进一步扩大化。</p><p>我之前的背景主要是做互联网框架、中间件和平台架构，之前工作过的公司eBay、携程、唯品会都是平台型互联网公司，所以今天主要带着系统和平台架构的视角和大家分享心得体会。架构的视角每个人都不一样，可以说是一万种眼光，有业务架构、平台架构、数据架构、安全架构等等，各不相同，这里仅仅是我的一家之言，欢迎大家参与讨论。</p><a id="more"></a><p>今天聊的话题主要包括以下几点：</p><ol><li>我对架构定义的理解</li><li>架构的迭代和演化性</li><li>构建闭环反馈架构</li><li>再谈微服务架构</li><li>架构和组织文化关系</li><li>架构师心态和软技能</li><li>我对一些架构争议主题的看法</li></ol><h3 id="一、我对架构定义的理解"><a href="#一、我对架构定义的理解" class="headerlink" title="一、我对架构定义的理解"></a>一、我对架构定义的理解</h3><p>大概10年前，我曾经有一个对口的美国架构导师，他对我讲架构其实是要找出干系人（stakeholders），然后解决他们的关注点(concerns)。后来我读到一本书《软件系统架构：使用视点和视角与利益相关者合作》，里面提到的理念也是这样的：系统架构的目标是解决利益相关者或者关系人的关注点。</p><p><img src="/images/20180517/whats_arch.png" alt="what&#39;s architecture"></p><p>这是从那本书里头截取的一张图，我之前分享架构定义常常用这张图，架构是这样定义的：</p><ol><li>每个系统都有一个架构，</li><li>架构由架构元素以及相互之间的关系构成，</li><li>系统是为了满足干系人（stakeholder）的需求而构建的，</li><li>干系人都有自己的关注点(concerns),</li><li>架构由架构文档描述，</li><li>架构文档描述了一系列的架构视角，</li><li>每个视角都对应到并解决干系人的关注点。</li></ol><p>对系统进行架构前，架构师的首要任务是尽最大可能找出所有的干系人，业务方、产品经理、客户/用户、开发经理，工程师、项目经理、测试人员、运维人员、产品运营人员等等都有可能是干系人，架构师要充分和干系人沟通，深入理解他们的关注点和痛点，并出架构解决这些关注点。架构师常犯错误是漏掉重要的干系人，沟通不充分，都会造成架构有欠缺，不能满足干系人的需求。干系人的关注点是有可能冲突的，比如管理层（可管理性）vs技术方(性能)，业务方(多快好省) vs 技术方（可靠稳定），这需要架构师去灵活平衡，如何平衡体现了架构师的水平和价值。</p><p>关于架构的第二点定义是说架构主要关注非功能性需求(non-functional requirements)，即所谓的-abilities，</p><p><img src="/images/20180517/ability.png" alt="non-functional requirements"></p><p>上图是我上次在公司内分享的一个图，</p><p><img src="/images/20180517/arch_requirements.png" alt="non-functional requirements"></p><p>上图是在slideshare上的一个ppt里头截取出来，两个图都是列出架构师经常需要关注的非功能性需求。</p><p>另外，去年我偶尔看到UML创始人Grady Booch是这样描述架构的：</p><blockquote><p>“Architecture represents the significant design decisions that shape a system, where significant is measured by cost of change”。<br>翻译成中文就是，架构表示对一个系统的成型起关键作用的设计决策， 架构定系统基本就成型了，这里的关键性可由变化造成的成本来衡量。</p></blockquote><p>进一步展开讲，架构的目标在于管理复杂性、易变性和不确定性，以确保在长期的系统演化过程中，一部分架构的变化不会对架构的其它部分产生不必要的负面影响。这样做可以确保业务和研发效率的敏捷，让应用的易变部分能够频繁地变化，对应用的其它部分的影响尽可能地小。</p><p>我进入软件开发行业之初，关注的架构主要是性能，高可能等方面。如今，见过无数遗留系统，特别是国内企业IT的现状，无数耦合性高的遗留系统，不良的架构像手铐一样牢牢地限制住业务，升级替换成本巨大，所以我现在更关注系统可扩展性，可维护性，可替换性，成本。我顺便补充一句，<strong>创业公司创业之初获得好的架构师或技术CTO非常重要</strong>，这种重要性在创业公司跨过Product/Market Fit之后，进入Scale规模化阶段就更加明显。</p><h3 id="二、架构的迭代和演化性"><a href="#二、架构的迭代和演化性" class="headerlink" title="二、架构的迭代和演化性"></a>二、架构的迭代和演化性</h3><p>我是属于老一代的架构师，99年参加工作。职业初期学了很多RUP(Rational Unified Process)，即统一软件过程的理念，RUP的理念对我的架构有很深的影响，RUP总结起来有三个特点：</p><ol><li>用例和风险驱动（Use Case and Risk Driven）</li><li>以架构为中心（Architecture Centric）</li><li>迭代和增量式开发（Iterative and Incremental）</li></ol><p>RUP注重架构，提倡以架构作为最大风险之一驱动开发，并提倡一开始要做端到端的原型prototype，通过压测等手段尽早验证架构可行性，然后在原型基础上持续迭代和增量开发，架构-&gt;开发-&gt;测试-&gt;调整架构-&gt;开发，循环，如下图所示：</p><p><img src="/images/20180517/arch_loop.png" alt="arch loop"></p><p>从上图看出，架构师要尽可能写代码，做测试，纯纸上谈兵式做架构而后丢给研发团队的作法非常不靠谱（除非是已经非常成熟清晰的领域）。</p><p>另外，做技术架构的都有点完美主义倾向，一开始往往喜欢求大求全，忽视架构的演化和迭代性，这种倾向易造产品和用户之间不能形成有效的反馈，产品不满足最终用户需求，继续看下面两个图：</p><p><img src="/images/20180517/mvp.png" alt="mvp"></p><p><img src="/images/20180517/over_engineering.png" alt="over engineering"></p><p>第一个图是讲最小可用产品（Minimum Viable Product， MVP）理念，做出最小可用产品，尽快丢给用户试用，快速获取客户反馈，在此基础上不断迭代和演化架构和产品。第二个图是过度工程(Over Engineering)的问题，其实也是讲产品架构和用户之间没有形成有效的反馈闭环，架构师想的和客户想的不在一个方向上，通过最小可用产品，快速迭代反馈的策略，可以避免这种问题。</p><p><strong>注意，在系统真正地投入生产使用之前，再好的架构都只是假设，产品越晚被使用者使用，失败的成本和风险就越高，而小步行进，通过MVP快速实验，获取客户反馈，迭代演化产品，能有效地减少失败的风险和成本。</strong></p><p>另外，多年的经验告诉我，架构，平台不是买来的，不是用一个开源能马上获得的，也不是单纯设计出来的，而是长期演化才能落地生根的，给大家推荐两篇不错的文章(具体链接可以用搜索引擎在网上搜一下)：</p><ol><li>58同城沈剑：好的架构源于不停地衍变，而非设计</li><li>宜人贷系统架构—高并发下的进化之路</li></ol><p>两篇文章都是讲互联网系统的迭代演化之路，值得每个架构师学习吸收。</p><h3 id="三、构建闭环反馈架构"><a href="#三、构建闭环反馈架构" class="headerlink" title="三、构建闭环反馈架构"></a>三、构建闭环反馈架构</h3><p>先分享这几年对我的架构理念影响最深的一篇文章的链接，这篇文章是关于DevOps的，但对系统架构同样适用。文章名称<a href="http://itrevolution.com/the-three-ways-principles-underpinning-devops/" target="_blank" rel="noopener">The Three Ways: The Principles Underpinning DevOps</a>。</p><p>这篇文章讲述了企业通向DevOps的三条必经之路，我们来看看这三条道路对架构师的启示：</p><p><img src="/images/20180517/first_way.png" alt="The First Way"></p><p>第一条道路，<strong>系统思维</strong>，开发驱动的组织机体，其能力不是制作软件，而是持续的交付客户价值，架构师需要有全局视角和系统思维(System Thinking)，深入理解整个价值交付链，从业务需求、研发、测试、集成，到部署运维。这条价值链的效率并不依赖于单个或者几个环节，局部优化的结果往往是全局受损，架构师要站在系统高度去优化整个价值交付链，让企业和客户之间形成快速和高效的价值传递。</p><p><img src="/images/20180517/second_way.png" alt="The Second Way"></p><p>第二条道路，<strong>强化反馈环</strong>，任何过程改进都是通过加强和缩短反馈环来达成的，而反馈需要测量和数据，有两句话值得推荐给大家：</p><ul><li>No measurement, no improvement，没有测量，就没有改进和提升</li><li>What you measure is what you get，你测量什么，就得到什么</li></ul><p>没有监控或者监控不完善的系统相当于开车上高速却无仪表盘，看不到反馈。Infoq上有一篇很不错的关于<a href="http://www.infoq.com/cn/articles/metrics-driven-development" target="_blank" rel="noopener">测量驱动开发</a>的文章，推荐阅读。</p><p>这篇文章提出了度量驱动开发的理念，即所谓MDD，在系统、应用和业务，通过三级监控，构建三个反馈环，在监控测量基础上持续改进系统和架构。我最近也在参考这个理念设计一个电商平台的技术架构体系，见下图：</p><p><img src="/images/20180517/platform_arch.png" alt="platform arch"></p><p>该体系同样采用了三级监控和闭环反馈的理念：</p><ul><li>系统层监控计算、网络、存储，构建系统层的反馈环，</li><li>应用服务层，监控业务、应用、服务，甚至整个研发流程，构建应用和服务层的反馈环，</li><li>客户体验层，监控端用户和分析网站用户的行为，构建和客户的反馈环。</li></ul><p>下面这个图展示了系统提升和改进的一般方法，</p><p><img src="/images/20180517/measure_loop.png" alt="measure loop"></p><p>收集-&gt;测量-&gt;调整-&gt;闭环重复，在有测量数据和反馈的基础上，系统、应用、流程和客户体验才有可能获得持续的提升和改善，否则没有数据的所谓改进只能靠拍脑袋或者说猜测。</p><p><img src="/images/20180517/third_way.png" alt="The Third Way"></p><p>第三条道路，<strong>鼓励勇于承担责任，冒险试错和持续提升的文化</strong>。这点是最难的，一般和企业人才密度有关。工具，技术，流程只是一个公司的冰山浮出水面的部分，而真正对企业效能影响大的则是冰山水下的部分，即企业的人和文化，架构师作为技术和架构的布道者，有责任义务鼓励和推动试错文化。</p><p>总之，架构师要深入领会这三条道路，关注整个价值交付链的效率，关注每个环节的闭环反馈，鼓励和推动公司的试错文化，打造全系统的闭环架构（Architecting for closed loop feedback），提升整个系统效能。下图的DevOps和每日交付是每一个互联网系统架构师的梦想和努力的方向。</p><p><img src="/images/20180517/devops_pipeline.png" alt="devops pipeline"></p><h3 id="四、再谈微服务"><a href="#四、再谈微服务" class="headerlink" title="四、再谈微服务"></a>四、再谈微服务</h3><p>微服务我想大家都听得很多了，我本人也非常关注和推崇微服务。从技术角度讲，我认为微服务主要体现的是单一职责和关注分离的思想，从单进程模块化进一步扩展到跨进程分布式的模块化。微服务是独立的开发、测试、部署和升级单元，正如我在第一点架构定义中提到的，微服务中每个服务可以独立演变，它的cost of change比较小，整体架构比较灵活，是一种支持创新的演化式架构。</p><p>MartinFowler之前写过两篇文章，给微服务泼凉水，建议大家好好读读：</p><ul><li><a href="http://martinfowler.com/bliki/MicroservicePrerequisites.html" target="_blank" rel="noopener">微服务先决条件</a></li><li><a href="http://martinfowler.com/bliki/MicroservicePremium.html" target="_blank" rel="noopener">微服务的额外成本</a></li></ul><p>第二篇文章里有个图，讲企业在什么时候引入微服务合适，</p><p><img src="/images/20180517/microservice_premium.png" alt="microservices premium"></p><p>微服务有额外成本，需要搭建配套的框架、发布和监控等基础设施。初创和小规模团队不建议采用。主要决定因素是系统复杂性和团队规模，当到达一个点，单块架构严重影响效率才考虑引入微服务。</p><p><strong>另外补充一点，微服务更多是关于组织和团队的，而不是技术。</strong></p><h3 id="五、架构和组织文化关系"><a href="#五、架构和组织文化关系" class="headerlink" title="五、架构和组织文化关系"></a>五、架构和组织文化关系</h3><p>再谈一下康威定律：</p><blockquote><p>Conway’s law: Organizations which design systems[…] are constrained to produce designs which are copies of the communication structures of these organizations.<br>（设计系统的组织，其产生的设计和架构等价于组织间的沟通结构。）</p></blockquote><p>从单块架构到微服务架构的衍变是这个定律的体现，</p><p><img src="/images/20180517/conway_law1.png" alt="conway&#39;s lay 1"></p><p>团队是分布式的，系统架构是单块的，开发、测试、部署协调沟通成本大，严重影响效率，严重时团队之间还容易起冲突conflict。</p><p><img src="/images/20180517/conway_law2.png" alt="conway&#39;s lay 2"></p><p>将单块架构解耦成微服务，每个团队开发，测试和发布自己负责的微服务，互不干扰，系统效率得到提升。</p><p>可见，组织和系统架构之间有一个映射关系（1 ~ 1 mapping），两者不对齐就会出各种各样的问题。一方面，如果你的组织结构和文化结构不支持，你就无法成功建立高效的系统架构，例如集中式和严格职能（业务/Dev/QA/Deployment/Ops）的企业，很难推行微服务和DevOps，这样的组织职能之间都倾向于局部优化（local optimization），难于形成有效的合作和闭环。</p><p>反过来也是成立的，如果你的系统设计或者架构不支持，那么你也就无法成功建立一个高效的组织。</p><p>作为系统架构师，一定要深入领会康威定律，设计系统架构之前，先看清组织结构，也要看组织文化（民主合作式、集权式、丛林法则式和人才密度等），再根据情况调整系统架构甚至是组织架构。</p><h3 id="六、架构师心态和软技能"><a href="#六、架构师心态和软技能" class="headerlink" title="六、架构师心态和软技能"></a>六、架构师心态和软技能</h3><p>空杯，或者说开放（open minded）心态，是一个成熟架构师的应有心态。你的杯子是空的，才能容纳新的东西，保持愚蠢，保持饥饿，心态有多开放，视野就有多开阔。与人沟通协作是不少技术型架构师的软肋，尤其在听到不同意见和不同视角观点的时候。这里有来自《高效能人士的七个习惯~史蒂芬.柯维》的一句话送给每一个架构师：</p><blockquote><p><strong>如果一位具有相当聪明才智的人跟我意见不同，那么对方的主张必有我尚未体会的奥秘，值得加以了解。与人合作最重要的是，重视不同个体的不同心理、情绪与智能，以及个人眼中所见的不同世界。与所见略同的人沟通，益处不大，要有分歧才有收获。</strong></p></blockquote><p>另外再推荐一本书《软件架构师的12项修炼》，这本书中的三个软技能观点值得每个架构师学习领会：</p><ol><li>Soft skills are always hard than hard skills，软技能比硬技能难</li><li>Choosing relationship over correctness，注重关系重于争论孰对孰错</li><li>架构的政治性，在大中型公司里工作的架构师尤其要学习。政治指的是和他人协作并将事情搞定的艺术，架构是一种社交活动，在技术的世界里，个人主义很容易被打败，即使你的目的是好的技术是最优的。技术决策是政治决策（technical decisions are political decisions），一个技术产品，一波人可以做，另一波人也可以做，到底谁做的好，真不好说，但不管谁做，都给业务套上了一副手铐。</li></ol><p>架构师如何提升？实战，实战，实战！管理好自己的时间，规划职业，找好的团队和项目，总结分享，学习GitHub开源项目，尽可能参与和开创自己的开源项目和产品，并长期积累。</p><h3 id="七、我对一些架构争议主题的看法"><a href="#七、我对一些架构争议主题的看法" class="headerlink" title="七、我对一些架构争议主题的看法"></a>七、我对一些架构争议主题的看法</h3><p>主要有两个争议主题：</p><ol><li>技术和业务的关系，</li><li>架构师要写代码吗？</li></ol><p>对于这类问题，一个聪明和有经验的回答是：视情况而定，不一定，是也不是，it depends。</p><p>技术和业务，架构师要理解业务吗？看产品和客户，如果是业务型产品，肯定要理解业务，如果是技术型产品，就不一定。但是技术产品也是有客户的，所以技术也好，业务也好，找准客户满足他们的需求是关键，脱离客户和产品，空谈技术或业务无意义。</p><p>架构师要写代码？也不一定，个人觉得尽可能要写，如果你写过十年以上代码了，每年不少于2万行，都玩通了，可以不写。另外架构师如果写代码，要把控度，不要一头钻入代码，花大量时间解决细节和复杂性问题，忽视全局和系统性问题。</p><h3 id="最后"><a href="#最后" class="headerlink" title="最后"></a>最后</h3><p>我想说中国现在的互联网发展趋势很好，越来越多的人加入架构师这个行业，这个行业正在”万物生长”。 但是我们现在还没有马丁福勒，adrian cockcroft这样的架构大牛人物。我辈仍需不断努力，期待中国10~20年后出现超过十个马丁福勒，adrian cockcroft这样的大牛级人物。</p><blockquote><p>我们必不可停止探索，而一切探索的尽头，就是重回起点，并对起点有首次般的认识。</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h3&gt;&lt;p&gt;近期我会陆陆续续把我之前在infoq/聊聊架构等媒体上发表的文章，陆续搬到我的个人公众号《波波微课》，这个是第一篇。&lt;/p&gt;
&lt;p&gt;这篇有特殊的意义，2015年下半年的时候，我还没有养成定期总结梳理的习惯，是极客邦的郭蕾鼓励我尝试。今天回头看，这个投资有很大价值，这一路积累了不少东西，后面需要持续积累，将价值和影响力进一步扩大化。&lt;/p&gt;
&lt;p&gt;我之前的背景主要是做互联网框架、中间件和平台架构，之前工作过的公司eBay、携程、唯品会都是平台型互联网公司，所以今天主要带着系统和平台架构的视角和大家分享心得体会。架构的视角每个人都不一样，可以说是一万种眼光，有业务架构、平台架构、数据架构、安全架构等等，各不相同，这里仅仅是我的一家之言，欢迎大家参与讨论。&lt;/p&gt;
    
    </summary>
    
      <category term="系统架构" scheme="http://yoursite.com/categories/%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84/"/>
    
    
      <category term="架构理念" scheme="http://yoursite.com/tags/%E6%9E%B6%E6%9E%84%E7%90%86%E5%BF%B5/"/>
    
  </entry>
  
  <entry>
    <title>攻城狮学习时间~六种结构模式</title>
    <link href="http://yoursite.com/2018/04/27/20180427/"/>
    <id>http://yoursite.com/2018/04/27/20180427/</id>
    <published>2018-04-27T11:25:55.000Z</published>
    <updated>2018-06-15T12:23:02.462Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>设计模式主要分为创建、结构和行为三类，其中结构模式在互联网和企业开发中有广泛应用。灵活运用结构模式，能够让代码结构更清晰，设计和扩展更灵活。在开发人员招聘面试过程中，有很多和结构模式相关的面试题，所以对结构模式的掌握和应用能力，可以作为衡量一个中高级开发人员或者架构师能力的重要参考。</p><a id="more"></a><p>结构模式主要分为六种，分别是：</p><ol><li>适配器（Adapter）模式</li><li>桥接器（Bridge）模式</li><li>组合（Composite）模式</li><li>装饰（Decorator）模式</li><li>门面（Facade）模式</li><li>代理（Proxy）模式</li></ol><p>在本微课中，波波老师将通过6个小视频，以原理+案例代码结合方式，深入浅出带领大家理解这6种主要结构模式的原理和实现技术，帮助开发人员在日常开发中能够做到灵活应用。</p><h3 id="结构模式"><a href="#结构模式" class="headerlink" title="结构模式"></a>结构模式</h3><table><thead><tr><th>名称</th><th>代码</th><th>ppt</th><th>视频</th></tr></thead><tbody><tr><td>适配器Adapter</td><td><a href="https://github.com/spring2go/core-spring-patterns/tree/master/patterns/structural/adapter" target="_blank" rel="noopener">code</a></td><td><a href="https://github.com/spring2go/core-spring-patterns/blob/master/ppts/%E9%80%82%E9%85%8D%E5%99%A8.pdf" target="_blank" rel="noopener">ppt</a></td><td><a href="https://v.qq.com/x/page/w0632njvzkw.html" target="_blank" rel="noopener">video</a></td></tr><tr><td>桥接器Bridge</td><td><a href="https://github.com/spring2go/core-spring-patterns/tree/master/patterns/structural/bridge" target="_blank" rel="noopener">code</a></td><td><a href="https://github.com/spring2go/core-spring-patterns/blob/master/ppts/%E6%A1%A5%E6%8E%A5%E5%99%A8.pdf" target="_blank" rel="noopener">ppt</a></td><td><a href="https://v.qq.com/x/page/h0632obkktb.html" target="_blank" rel="noopener">video</a></td></tr><tr><td>组合Composite</td><td><a href="https://github.com/spring2go/core-spring-patterns/tree/master/patterns/structural/composite" target="_blank" rel="noopener">code</a></td><td><a href="https://github.com/spring2go/core-spring-patterns/blob/master/ppts/%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F.pdf" target="_blank" rel="noopener">ppt</a></td><td><a href="https://v.qq.com/x/page/t0634x9lbew.html" target="_blank" rel="noopener">video</a></td></tr><tr><td>装饰Decorator</td><td><a href="https://github.com/spring2go/core-spring-patterns/tree/master/patterns/structural/decorator" target="_blank" rel="noopener">code</a></td><td><a href="https://github.com/spring2go/core-spring-patterns/blob/master/ppts/%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.pdf" target="_blank" rel="noopener">ppt</a></td><td><a href="https://v.qq.com/x/page/p0636w3d6s2.html" target="_blank" rel="noopener">video</a></td></tr><tr><td>门面Facade</td><td><a href="https://github.com/spring2go/core-spring-patterns/tree/master/patterns/structural/facade" target="_blank" rel="noopener">code</a></td><td><a href="https://github.com/spring2go/core-spring-patterns/blob/master/ppts/%E9%97%A8%E9%9D%A2%E6%A8%A1%E5%BC%8F.pdf" target="_blank" rel="noopener">ppt</a></td><td><a href="https://v.qq.com/x/page/m06379lgexy.html" target="_blank" rel="noopener">video</a></td></tr><tr><td>代理Proxy</td><td><a href="https://github.com/spring2go/core-spring-patterns/tree/master/patterns/structural/proxy" target="_blank" rel="noopener">code</a></td><td><a href="https://github.com/spring2go/core-spring-patterns/blob/master/ppts/%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.pdf" target="_blank" rel="noopener">ppt</a></td><td><a href="https://v.qq.com/x/page/k0637354wuw.html" target="_blank" rel="noopener">video</a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;设计模式主要分为创建、结构和行为三类，其中结构模式在互联网和企业开发中有广泛应用。灵活运用结构模式，能够让代码结构更清晰，设计和扩展更灵活。在开发人员招聘面试过程中，有很多和结构模式相关的面试题，所以对结构模式的掌握和应用能力，可以作为衡量一个中高级开发人员或者架构师能力的重要参考。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="结构模式" scheme="http://yoursite.com/tags/%E7%BB%93%E6%9E%84%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>攻城狮学习时间~七种创建模式</title>
    <link href="http://yoursite.com/2018/04/18/20180418/"/>
    <id>http://yoursite.com/2018/04/18/20180418/</id>
    <published>2018-04-18T12:02:59.000Z</published>
    <updated>2018-06-15T12:22:35.413Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>设计模式主要分创建，结构和行为三类，其中创建模式是应用最广和开发人员在日常工作中打交道最多的，熟练掌握创建模式可以认为是初级开发人员和中高级开发人员的一个分水岭。</p><a id="more"></a><p>创建模式主要分七种，分别是：</p><ol><li>单例(Singleton)模式</li><li>简单工厂(Simple Factory)模式</li><li>工厂方法(Factory Method)模式</li><li>抽象工厂(Abstract Factory)模式</li><li>依赖注入(Dependency Injection)模式</li><li>构造者(Builder)模式</li><li>流畅接口(Fluent Interface)模式</li></ol><p>在本微课中，波波老师将通过7个小视频，以原理+案例代码结合方式，深入浅出带领大家理解这7种主要创建模式的原理和实现技术，帮助开发人员在日常开发中能够做到灵活应用。</p><h3 id="创建模式"><a href="#创建模式" class="headerlink" title="创建模式"></a>创建模式</h3><table><thead><tr><th>名称</th><th>代码</th><th>ppt</th><th>视频</th></tr></thead><tbody><tr><td>单例Singleton</td><td><a href="https://github.com/spring2go/core-spring-patterns/tree/master/patterns/creation/singleton" target="_blank" rel="noopener">code</a></td><td><a href="https://github.com/spring2go/core-spring-patterns/blob/master/ppts/%E5%8D%95%E4%BE%8B.pdf" target="_blank" rel="noopener">ppt</a></td><td><a href="https://v.qq.com/x/page/s0630rqg9wg.html" target="_blank" rel="noopener">video</a></td></tr><tr><td>简单工厂Simple Factory</td><td><a href="https://github.com/spring2go/core-spring-patterns/tree/master/patterns/creation/simple-factory" target="_blank" rel="noopener">code</a></td><td><a href="https://github.com/spring2go/core-spring-patterns/blob/master/ppts/%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82.pdf" target="_blank" rel="noopener">ppt</a></td><td><a href="https://v.qq.com/x/page/n0629exrd31.html" target="_blank" rel="noopener">video</a></td></tr><tr><td>工厂方法Factory Method</td><td><a href="https://github.com/spring2go/core-spring-patterns/tree/master/patterns/creation/factory-method" target="_blank" rel="noopener">code</a></td><td><a href="https://github.com/spring2go/core-spring-patterns/blob/master/ppts/%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95.pdf" target="_blank" rel="noopener">ppt</a></td><td><a href="https://v.qq.com/x/page/a0629kh0xxc.html" target="_blank" rel="noopener">video</a></td></tr><tr><td>抽象工厂Abstract Factory</td><td><a href="https://github.com/spring2go/core-spring-patterns/tree/master/patterns/creation/abstract-factory" target="_blank" rel="noopener">code</a></td><td><a href="https://github.com/spring2go/core-spring-patterns/blob/master/ppts/%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82.pdf" target="_blank" rel="noopener">ppt</a></td><td><a href="https://v.qq.com/x/page/p0629psr89t.html" target="_blank" rel="noopener">video</a></td></tr><tr><td>依赖注入Dependency Injection</td><td><a href="https://github.com/spring2go/core-spring-patterns/tree/master/patterns/general/dependency-inversion" target="_blank" rel="noopener">code</a></td><td><a href="https://github.com/spring2go/core-spring-patterns/blob/master/ppts/DIP+IoC+DI.pdf" target="_blank" rel="noopener">ppt</a></td><td><a href="https://v.qq.com/x/page/k0629qsrpz5.html" target="_blank" rel="noopener">video</a></td></tr><tr><td>构造者Builder</td><td><a href="https://github.com/spring2go/core-spring-patterns/tree/master/patterns/creation/builder" target="_blank" rel="noopener">code</a></td><td><a href="https://github.com/spring2go/core-spring-patterns/blob/master/ppts/%E6%9E%84%E5%BB%BA%E8%80%85.pdf" target="_blank" rel="noopener">ppt</a></td><td><a href="https://v.qq.com/x/page/z0630bg1qs3.html" target="_blank" rel="noopener">video</a></td></tr><tr><td>流畅接口Fluent Interface</td><td><a href="https://github.com/spring2go/core-spring-patterns/tree/master/patterns/creation/builder" target="_blank" rel="noopener">code</a></td><td><a href="https://github.com/spring2go/core-spring-patterns/blob/master/ppts/%E6%B5%81%E7%95%85%E6%8E%A5%E5%8F%A3.pdf" target="_blank" rel="noopener">ppt</a></td><td><a href="https://v.qq.com/x/page/v063000n872.html" target="_blank" rel="noopener">video</a></td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;设计模式主要分创建，结构和行为三类，其中创建模式是应用最广和开发人员在日常工作中打交道最多的，熟练掌握创建模式可以认为是初级开发人员和中高级开发人员的一个分水岭。&lt;/p&gt;
    
    </summary>
    
      <category term="设计模式" scheme="http://yoursite.com/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
    
      <category term="设计模式" scheme="http://yoursite.com/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
      <category term="创建模式" scheme="http://yoursite.com/tags/%E5%88%9B%E5%BB%BA%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
</feed>
